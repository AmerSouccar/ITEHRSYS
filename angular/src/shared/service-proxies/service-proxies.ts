//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AssignmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assignment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadAssignmentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Assignment/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAssignmentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAssignmentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadAssignmentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAssignmentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Assignment/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAssignmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAssignmentDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertAssignmentDto | undefined): Observable<InsertAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Assignment/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertAssignmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertAssignmentDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAssignmentDto | undefined): Observable<UpdateAssignmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Assignment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateAssignmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateAssignmentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateAssignmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAssignmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttachmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param title (optional) 
     * @param description (optional) 
     * @param file (optional) 
     * @return Success
     */
    insert(title: string | undefined, description: string | undefined, file: FileParameter | undefined): Observable<ReadAttachmentDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachment/Insert?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        if (description === null)
            throw new Error("The parameter 'description' cannot be null.");
        else if (description !== undefined)
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttachmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttachmentDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ReadAttachmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttachmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttendanceFormServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadAttendanceFormDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceFormDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceFormDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadAttendanceFormDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceFormDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadAttendanceFormDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceFormDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadAttendanceFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateAttendanceFormDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateAttendanceFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateAttendanceFormDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateAttendanceFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAttendanceFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertAttendanceFormDto | undefined): Observable<InsertAttendanceFormDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertAttendanceFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertAttendanceFormDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertAttendanceFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertAttendanceFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAttendanceFormDto | undefined): Observable<UpdateAttendanceFormDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceForm/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateAttendanceFormDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateAttendanceFormDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateAttendanceFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAttendanceFormDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttendanceMonthlyCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadAttendanceMonthlyCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceMonthlyCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceMonthlyCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadAttendanceMonthlyCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceMonthlyCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllbyId(id: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadAttendanceMonthlyCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/GetAllbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceMonthlyCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceMonthlyCardDtoPagedResultDto>;
        }));
    }

    protected processGetAllbyId(response: HttpResponseBase): Observable<ReadAttendanceMonthlyCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceMonthlyCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadAttendanceMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceMonthlyCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadAttendanceMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertAttendanceMonthlyCardDto | undefined): Observable<InsertAttendanceMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertAttendanceMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertAttendanceMonthlyCardDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertAttendanceMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertAttendanceMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAttendanceMonthlyCardDto | undefined): Observable<UpdateAttendanceMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceMonthlyCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateAttendanceMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateAttendanceMonthlyCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateAttendanceMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAttendanceMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AttendanceRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    calculateMonth(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/CalculateMonth?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalculateMonth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateMonthlyCards(id: string | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/GenerateMonthlyCards?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateMonthlyCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateMonthlyCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateMonthlyCards(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadAttendanceRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceRecordDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceRecordDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadAttendanceRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceRecordDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadAttendanceRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadAttendanceRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadAttendanceRecordDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadAttendanceRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadAttendanceRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertAttendanceRecordDto | undefined): Observable<InsertAttendanceRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertAttendanceRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertAttendanceRecordDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertAttendanceRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertAttendanceRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateAttendanceRecordDto | undefined): Observable<UpdateAttendanceRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/AttendanceRecord/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateAttendanceRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateAttendanceRecordDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateAttendanceRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateAttendanceRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadBankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBankDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBankDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadBankDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBankDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadBankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBankDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertBankDto | undefined): Observable<InsertBankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertBankDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertBankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBankDto | undefined): Observable<UpdateBankDto> {
        let url_ = this.baseUrl + "/api/services/app/Bank/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateBankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateBankDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateBankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateBankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BankInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BankInformation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadBankInformationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BankInformation/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBankInformationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBankInformationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadBankInformationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBankInformationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadBankInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/BankInformation/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBankInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBankInformationDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadBankInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBankInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertBankInformationDto | undefined): Observable<InsertBankInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/BankInformation/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertBankInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertBankInformationDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertBankInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertBankInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBankInformationDto | undefined): Observable<UpdateBankInformationDto> {
        let url_ = this.baseUrl + "/api/services/app/BankInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateBankInformationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateBankInformationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateBankInformationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateBankInformationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class BenefitCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BenefitCard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadBenefitCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BenefitCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBenefitCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBenefitCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadBenefitCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBenefitCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadBenefitCardDto> {
        let url_ = this.baseUrl + "/api/services/app/BenefitCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadBenefitCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadBenefitCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadBenefitCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadBenefitCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertBenefitCardDto | undefined): Observable<InsertBenefitCardDto> {
        let url_ = this.baseUrl + "/api/services/app/BenefitCard/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertBenefitCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertBenefitCardDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertBenefitCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertBenefitCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBenefitCardDto | undefined): Observable<UpdateBenefitCardDto> {
        let url_ = this.baseUrl + "/api/services/app/BenefitCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateBenefitCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateBenefitCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateBenefitCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateBenefitCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CertificateServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Certificate/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadCertificateDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Certificate/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCertificateDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCertificateDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadCertificateDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCertificateDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadCertificateDto> {
        let url_ = this.baseUrl + "/api/services/app/Certificate/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCertificateDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadCertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertCertificateDto | undefined): Observable<InsertCertificateDto> {
        let url_ = this.baseUrl + "/api/services/app/Certificate/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertCertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertCertificateDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertCertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertCertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCertificateDto | undefined): Observable<UpdateCertificateDto> {
        let url_ = this.baseUrl + "/api/services/app/Certificate/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCertificateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCertificateDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateCertificateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCertificateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChangeableHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadChangeableHolidayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadChangeableHolidayDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadChangeableHolidayDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadChangeableHolidayDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadChangeableHolidayDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadChangeableHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadChangeableHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadChangeableHolidayDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadChangeableHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadChangeableHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateChangeableHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateChangeableHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateChangeableHolidayDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateChangeableHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateChangeableHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertChangeableHolidayDto | undefined): Observable<InsertChangeableHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertChangeableHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertChangeableHolidayDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertChangeableHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertChangeableHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateChangeableHolidayDto | undefined): Observable<UpdateChangeableHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/ChangeableHoliday/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateChangeableHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateChangeableHolidayDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateChangeableHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateChangeableHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChildrenServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Children/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadChildrenDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Children/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadChildrenDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadChildrenDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadChildrenDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadChildrenDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadChildrenDto> {
        let url_ = this.baseUrl + "/api/services/app/Children/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadChildrenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadChildrenDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadChildrenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadChildrenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertChildrenDto | undefined): Observable<InsertChildrenDto> {
        let url_ = this.baseUrl + "/api/services/app/Children/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertChildrenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertChildrenDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertChildrenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertChildrenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateChildrenDto | undefined): Observable<UpdateChildrenDto> {
        let url_ = this.baseUrl + "/api/services/app/Children/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateChildrenDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateChildrenDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateChildrenDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateChildrenDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/City/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/services/app/City/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/City/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CityDto | undefined): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/services/app/City/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CityDto | undefined): Observable<CityDto> {
        let url_ = this.baseUrl + "/api/services/app/City/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CompanyHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadCompanyHolidayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCompanyHolidayDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCompanyHolidayDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadCompanyHolidayDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCompanyHolidayDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadCompanyHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCompanyHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCompanyHolidayDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadCompanyHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCompanyHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateCompanyHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyHolidayDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateCompanyHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertCompanyHolidayDto | undefined): Observable<InsertCompanyHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertCompanyHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertCompanyHolidayDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertCompanyHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertCompanyHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCompanyHolidayDto | undefined): Observable<UpdateCompanyHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyHoliday/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyHolidayDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateCompanyHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ConvictionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Conviction/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadConvictionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Conviction/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadConvictionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadConvictionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadConvictionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadConvictionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadConvictionDto> {
        let url_ = this.baseUrl + "/api/services/app/Conviction/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadConvictionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadConvictionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadConvictionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadConvictionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertConvictionDto | undefined): Observable<InsertConvictionDto> {
        let url_ = this.baseUrl + "/api/services/app/Conviction/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertConvictionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertConvictionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertConvictionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertConvictionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateConvictionDto | undefined): Observable<UpdateConvictionDto> {
        let url_ = this.baseUrl + "/api/services/app/Conviction/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateConvictionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateConvictionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateConvictionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateConvictionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<CountryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: CountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: CountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CustodieServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Custodie/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadCustodieDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Custodie/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCustodieDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCustodieDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadCustodieDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCustodieDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadCustodieDto> {
        let url_ = this.baseUrl + "/api/services/app/Custodie/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadCustodieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadCustodieDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadCustodieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadCustodieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertCustodieDto | undefined): Observable<InsertCustodieDto> {
        let url_ = this.baseUrl + "/api/services/app/Custodie/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertCustodieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertCustodieDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertCustodieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertCustodieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCustodieDto | undefined): Observable<UpdateCustodieDto> {
        let url_ = this.baseUrl + "/api/services/app/Custodie/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCustodieDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCustodieDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateCustodieDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCustodieDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DeductionCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DeductionCard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadDeductionCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DeductionCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDeductionCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDeductionCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadDeductionCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDeductionCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadDeductionCardDto> {
        let url_ = this.baseUrl + "/api/services/app/DeductionCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDeductionCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDeductionCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadDeductionCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDeductionCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertDeductionCardDto | undefined): Observable<InsertDeductionCardDto> {
        let url_ = this.baseUrl + "/api/services/app/DeductionCard/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertDeductionCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertDeductionCardDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertDeductionCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertDeductionCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDeductionCardDto | undefined): Observable<UpdateDeductionCardDto> {
        let url_ = this.baseUrl + "/api/services/app/DeductionCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateDeductionCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateDeductionCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateDeductionCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateDeductionCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DependentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Dependent/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadDependentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Dependent/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDependentDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDependentDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadDependentDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDependentDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/Dependent/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDependentDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertDependentDto | undefined): Observable<InsertDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/Dependent/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertDependentDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDependentDto | undefined): Observable<UpdateDependentDto> {
        let url_ = this.baseUrl + "/api/services/app/Dependent/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateDependentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateDependentDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateDependentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateDependentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DriverLicenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicense/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadDriverLicenseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicense/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDriverLicenseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDriverLicenseDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadDriverLicenseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDriverLicenseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadDriverLicenseDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicense/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadDriverLicenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadDriverLicenseDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadDriverLicenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadDriverLicenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertDriverLicenseDto | undefined): Observable<InsertDriverLicenseDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicense/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertDriverLicenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertDriverLicenseDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertDriverLicenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertDriverLicenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDriverLicenseDto | undefined): Observable<UpdateDriverLicenseDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicense/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateDriverLicenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateDriverLicenseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateDriverLicenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateDriverLicenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DriverLicenseTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<DriverLicenseTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DriverLicenseTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<DriverLicenseTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseTypeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<DriverLicenseTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: DriverLicenseTypeDto | undefined): Observable<DriverLicenseTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseTypeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<DriverLicenseTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DriverLicenseTypeDto | undefined): Observable<DriverLicenseTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DriverLicenseType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DriverLicenseTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DriverLicenseTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DriverLicenseTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DriverLicenseTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EducationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Education/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEducationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Education/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEducationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEducationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadEducationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEducationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadEducationDto> {
        let url_ = this.baseUrl + "/api/services/app/Education/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEducationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEducationDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadEducationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEducationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertEducationDto | undefined): Observable<InsertEducationDto> {
        let url_ = this.baseUrl + "/api/services/app/Education/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertEducationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertEducationDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertEducationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertEducationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEducationDto | undefined): Observable<UpdateEducationDto> {
        let url_ = this.baseUrl + "/api/services/app/Education/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEducationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEducationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateEducationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEducationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EducationGradeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEducationGradeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEducationGradeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEducationGradeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadEducationGradeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEducationGradeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadEducationGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEducationGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEducationGradeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadEducationGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEducationGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateEducationGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEducationGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEducationGradeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateEducationGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEducationGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertEducationGradeDto | undefined): Observable<InsertEducationGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertEducationGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertEducationGradeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertEducationGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertEducationGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEducationGradeDto | undefined): Observable<UpdateEducationGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationGrade/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEducationGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEducationGradeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateEducationGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEducationGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EducationMajorServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EducationMajor/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<EducationMajorDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationMajor/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationMajorDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationMajorDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EducationMajorDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationMajorDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<EducationMajorDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationMajor/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationMajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationMajorDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<EducationMajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationMajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: EducationMajorDto | undefined): Observable<EducationMajorDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationMajor/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationMajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationMajorDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<EducationMajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationMajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EducationMajorDto | undefined): Observable<EducationMajorDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationMajor/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationMajorDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationMajorDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EducationMajorDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationMajorDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EducationTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EducationType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<EducationTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EducationTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<EducationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationType/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationTypeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<EducationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: EducationTypeDto | undefined): Observable<EducationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationTypeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<EducationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: EducationTypeDto | undefined): Observable<EducationTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/EducationType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EducationTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EducationTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<EducationTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EducationTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEmployeeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEmployeeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEmployeeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadEmployeeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEmployeeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadEmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEmployeeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateEmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEmployeeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertEmployeeDto | undefined): Observable<InsertEmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertEmployeeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEmployeeDto | undefined): Observable<UpdateEmployeeDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEmployeeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateEmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EmployeeCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEmployeeCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEmployeeCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEmployeeCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadEmployeeCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEmployeeCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllForDropdown(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEmployeeCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeCard/GetAllForDropdown?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEmployeeCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEmployeeCardDtoPagedResultDto>;
        }));
    }

    protected processGetAllForDropdown(response: HttpResponseBase): Observable<ReadEmployeeCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEmployeeCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadEmployeeCardDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEmployeeCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEmployeeCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadEmployeeCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEmployeeCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateEmployeeCardDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeCard/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEmployeeCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEmployeeCardDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateEmployeeCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEmployeeCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEmployeeCardDto | undefined): Observable<UpdateEmployeeCardDto> {
        let url_ = this.baseUrl + "/api/services/app/EmployeeCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEmployeeCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEmployeeCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateEmployeeCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEmployeeCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EntranceExitRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadEntranceExitRecordDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEntranceExitRecordDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEntranceExitRecordDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadEntranceExitRecordDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEntranceExitRecordDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadEntranceExitRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadEntranceExitRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadEntranceExitRecordDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadEntranceExitRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadEntranceExitRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateEntranceExitRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEntranceExitRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEntranceExitRecordDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateEntranceExitRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEntranceExitRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param file (optional) 
     * @return Success
     */
    importDataFromExcel(file: FileParameter | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/ImportDataFromExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportDataFromExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportDataFromExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportDataFromExcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertEntranceExitRecordDto | undefined): Observable<InsertEntranceExitRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertEntranceExitRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertEntranceExitRecordDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertEntranceExitRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertEntranceExitRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateEntranceExitRecordDto | undefined): Observable<UpdateEntranceExitRecordDto> {
        let url_ = this.baseUrl + "/api/services/app/EntranceExitRecord/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateEntranceExitRecordDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateEntranceExitRecordDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateEntranceExitRecordDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateEntranceExitRecordDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ExperienceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Experience/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadExperienceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Experience/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadExperienceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadExperienceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadExperienceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadExperienceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadExperienceDto> {
        let url_ = this.baseUrl + "/api/services/app/Experience/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadExperienceDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertExperienceDto | undefined): Observable<InsertExperienceDto> {
        let url_ = this.baseUrl + "/api/services/app/Experience/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertExperienceDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateExperienceDto | undefined): Observable<UpdateExperienceDto> {
        let url_ = this.baseUrl + "/api/services/app/Experience/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateExperienceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateExperienceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateExperienceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateExperienceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FinancialCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadFinancialCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadFinancialCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadFinancialCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadFinancialCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadFinancialCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadFinancialCardDto> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadFinancialCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadFinancialCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadFinancialCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadFinancialCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateFinancialCardDto> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFinancialCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFinancialCardDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateFinancialCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFinancialCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertFinancialCardDto | undefined): Observable<InsertFinancialCardDto> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertFinancialCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertFinancialCardDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertFinancialCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertFinancialCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFinancialCardDto | undefined): Observable<UpdateFinancialCardDto> {
        let url_ = this.baseUrl + "/api/services/app/FinancialCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFinancialCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFinancialCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateFinancialCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFinancialCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FixedHolidayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadFixedHolidayDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadFixedHolidayDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadFixedHolidayDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadFixedHolidayDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadFixedHolidayDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadFixedHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadFixedHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadFixedHolidayDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadFixedHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadFixedHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateFixedHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFixedHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFixedHolidayDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateFixedHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFixedHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertFixedHolidayDto | undefined): Observable<InsertFixedHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertFixedHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertFixedHolidayDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertFixedHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertFixedHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFixedHolidayDto | undefined): Observable<UpdateFixedHolidayDto> {
        let url_ = this.baseUrl + "/api/services/app/FixedHoliday/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateFixedHolidayDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateFixedHolidayDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateFixedHolidayDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateFixedHolidayDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GradeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Grade/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadGradeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Grade/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGradeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGradeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadGradeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGradeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/Grade/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGradeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/Grade/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGradeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertGradeDto | undefined): Observable<InsertGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/Grade/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertGradeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateGradeDto | undefined): Observable<UpdateGradeDto> {
        let url_ = this.baseUrl + "/api/services/app/Grade/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGradeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGradeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateGradeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGradeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HourlyMissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HourlyMission/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadHourlyMissionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/HourlyMission/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadHourlyMissionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadHourlyMissionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadHourlyMissionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadHourlyMissionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadHourlyMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/HourlyMission/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadHourlyMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadHourlyMissionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadHourlyMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadHourlyMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertHourlyMissionDto | undefined): Observable<InsertHourlyMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/HourlyMission/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertHourlyMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertHourlyMissionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertHourlyMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertHourlyMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateHourlyMissionDto | undefined): Observable<UpdateHourlyMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/HourlyMission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateHourlyMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateHourlyMissionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateHourlyMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateHourlyMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobDescriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadJobDescriptionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadJobDescriptionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadJobDescriptionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadJobDescriptionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadJobDescriptionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadJobDescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadJobDescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadJobDescriptionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadJobDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadJobDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateJobDescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateJobDescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateJobDescriptionDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateJobDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateJobDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertJobDescriptionDto | undefined): Observable<InsertJobDescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertJobDescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertJobDescriptionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertJobDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertJobDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateJobDescriptionDto | undefined): Observable<UpdateJobDescriptionDto> {
        let url_ = this.baseUrl + "/api/services/app/JobDescription/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateJobDescriptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateJobDescriptionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateJobDescriptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateJobDescriptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobTitleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadJobTitleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadJobTitleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadJobTitleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadJobTitleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadJobTitleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllbyId(id: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadJobTitleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetAllbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadJobTitleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadJobTitleDtoPagedResultDto>;
        }));
    }

    protected processGetAllbyId(response: HttpResponseBase): Observable<ReadJobTitleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadJobTitleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadJobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadJobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadJobTitleDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadJobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadJobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateJobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateJobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateJobTitleDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateJobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateJobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertJobTitleDto | undefined): Observable<InsertJobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertJobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertJobTitleDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertJobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertJobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateJobTitleDto | undefined): Observable<UpdateJobTitleDto> {
        let url_ = this.baseUrl + "/api/services/app/JobTitle/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateJobTitleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateJobTitleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateJobTitleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateJobTitleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class KinshipTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/KinshipType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<KinshipTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/KinshipType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KinshipTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KinshipTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<KinshipTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KinshipTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<KinshipTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/KinshipType/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KinshipTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KinshipTypeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<KinshipTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KinshipTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: KinshipTypeDto | undefined): Observable<KinshipTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/KinshipType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KinshipTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KinshipTypeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<KinshipTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KinshipTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: KinshipTypeDto | undefined): Observable<KinshipTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/KinshipType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KinshipTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KinshipTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<KinshipTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KinshipTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadLanguageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLanguageDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLanguageDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadLanguageDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLanguageDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadLanguageDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLanguageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLanguageDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadLanguageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLanguageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertLanguageDto | undefined): Observable<InsertLanguageDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertLanguageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertLanguageDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertLanguageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertLanguageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLanguageDto | undefined): Observable<UpdateLanguageDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLanguageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLanguageDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateLanguageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLanguageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageNameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LanguageName/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<LanguageNameDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LanguageName/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageNameDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageNameDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LanguageNameDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageNameDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<LanguageNameDto> {
        let url_ = this.baseUrl + "/api/services/app/LanguageName/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageNameDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageNameDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<LanguageNameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageNameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: LanguageNameDto | undefined): Observable<LanguageNameDto> {
        let url_ = this.baseUrl + "/api/services/app/LanguageName/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageNameDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageNameDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<LanguageNameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageNameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LanguageNameDto | undefined): Observable<LanguageNameDto> {
        let url_ = this.baseUrl + "/api/services/app/LanguageName/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageNameDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageNameDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LanguageNameDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LanguageNameDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LeaveRequestServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    acceptLeaveRequest(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/AcceptLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptLeaveRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadLeaveRequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLeaveRequestDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLeaveRequestDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadLeaveRequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLeaveRequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadLeaveRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLeaveRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLeaveRequestDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadLeaveRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLeaveRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getMyEmployeesLeaveRequests(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadLeaveRequestDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/GetMyEmployeesLeaveRequests?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyEmployeesLeaveRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyEmployeesLeaveRequests(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLeaveRequestDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLeaveRequestDtoPagedResultDto>;
        }));
    }

    protected processGetMyEmployeesLeaveRequests(response: HttpResponseBase): Observable<ReadLeaveRequestDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLeaveRequestDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertLeaveRequestDto | undefined): Observable<InsertLeaveRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertLeaveRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertLeaveRequestDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertLeaveRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertLeaveRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    rejectLeaveRequest(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/RejectLeaveRequest?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectLeaveRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectLeaveRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRejectLeaveRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    requestLeave(body: InsertLeaveRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/RequestLeave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestLeave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestLeave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestLeave(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLeaveRequestDto | undefined): Observable<UpdateLeaveRequestDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveRequest/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLeaveRequestDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLeaveRequestDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateLeaveRequestDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLeaveRequestDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LeaveSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadLeaveSettingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLeaveSettingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLeaveSettingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadLeaveSettingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLeaveSettingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadLeaveSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadLeaveSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadLeaveSettingDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadLeaveSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadLeaveSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateLeaveSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLeaveSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLeaveSettingDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateLeaveSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLeaveSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertLeaveSettingDto | undefined): Observable<InsertLeaveSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertLeaveSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertLeaveSettingDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertLeaveSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertLeaveSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLeaveSettingDto | undefined): Observable<UpdateLeaveSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaveSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateLeaveSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateLeaveSettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateLeaveSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateLeaveSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Level/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<LevelDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Level/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LevelDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LevelDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<LevelDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LevelDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<LevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Level/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LevelDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<LevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: LevelDto | undefined): Observable<LevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Level/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LevelDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<LevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: LevelDto | undefined): Observable<LevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Level/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LevelDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<LevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MilitaryServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MilitaryService/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadMilitaryServiceDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MilitaryService/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMilitaryServiceDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMilitaryServiceDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadMilitaryServiceDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMilitaryServiceDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadMilitaryServiceDto> {
        let url_ = this.baseUrl + "/api/services/app/MilitaryService/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMilitaryServiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMilitaryServiceDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadMilitaryServiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMilitaryServiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertMilitaryServiceDto | undefined): Observable<InsertMilitaryServiceDto> {
        let url_ = this.baseUrl + "/api/services/app/MilitaryService/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMilitaryServiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMilitaryServiceDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertMilitaryServiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMilitaryServiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMilitaryServiceDto | undefined): Observable<UpdateMilitaryServiceDto> {
        let url_ = this.baseUrl + "/api/services/app/MilitaryService/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateMilitaryServiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateMilitaryServiceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateMilitaryServiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateMilitaryServiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MonthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    calculateMonth(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Month/CalculateMonth?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateMonth(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateMonth(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalculateMonth(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Month/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param body (optional) 
     * @return Success
     */
    generateMonthlyCards(id: string | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Month/GenerateMonthlyCards?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateMonthlyCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateMonthlyCards(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGenerateMonthlyCards(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadMonthDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Month/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMonthDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMonthDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadMonthDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMonthDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadMonthDto> {
        let url_ = this.baseUrl + "/api/services/app/Month/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMonthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMonthDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadMonthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMonthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertMonthDto | undefined): Observable<InsertMonthDto> {
        let url_ = this.baseUrl + "/api/services/app/Month/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMonthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMonthDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertMonthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMonthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMonthDto | undefined): Observable<UpdateMonthDto> {
        let url_ = this.baseUrl + "/api/services/app/Month/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateMonthDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateMonthDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateMonthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateMonthDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MonthlyCardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadMonthlyCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMonthlyCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMonthlyCardDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadMonthlyCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMonthlyCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllbyId(id: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadMonthlyCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/GetAllbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMonthlyCardDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMonthlyCardDtoPagedResultDto>;
        }));
    }

    protected processGetAllbyId(response: HttpResponseBase): Observable<ReadMonthlyCardDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMonthlyCardDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadMonthlyCardDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertMonthlyCardDto | undefined): Observable<InsertMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertMonthlyCardDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateMonthlyCardDto | undefined): Observable<UpdateMonthlyCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MonthlyCard/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateMonthlyCardDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateMonthlyCardDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateMonthlyCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateMonthlyCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NationalityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Nationality/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<NationalityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Nationality/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NationalityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NationalityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<NationalityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NationalityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<NationalityDto> {
        let url_ = this.baseUrl + "/api/services/app/Nationality/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NationalityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NationalityDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<NationalityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NationalityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: NationalityDto | undefined): Observable<NationalityDto> {
        let url_ = this.baseUrl + "/api/services/app/Nationality/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NationalityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NationalityDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<NationalityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NationalityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: NationalityDto | undefined): Observable<NationalityDto> {
        let url_ = this.baseUrl + "/api/services/app/Nationality/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NationalityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NationalityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<NationalityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NationalityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NodeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Node/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadNodeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Node/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadNodeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadNodeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadNodeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadNodeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadNodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Node/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadNodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadNodeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadNodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadNodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateNodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Node/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateNodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateNodeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateNodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateNodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertNodeDto | undefined): Observable<InsertNodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Node/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertNodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertNodeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertNodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertNodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateNodeDto | undefined): Observable<UpdateNodeDto> {
        let url_ = this.baseUrl + "/api/services/app/Node/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateNodeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateNodeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateNodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateNodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NormalShiftServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadNormalShiftDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadNormalShiftDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadNormalShiftDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadNormalShiftDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadNormalShiftDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param workshopId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllById(workshopId: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadNormalShiftDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/GetAllById?";
        if (workshopId === null)
            throw new Error("The parameter 'workshopId' cannot be null.");
        else if (workshopId !== undefined)
            url_ += "WorkshopId=" + encodeURIComponent("" + workshopId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadNormalShiftDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadNormalShiftDtoPagedResultDto>;
        }));
    }

    protected processGetAllById(response: HttpResponseBase): Observable<ReadNormalShiftDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadNormalShiftDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadNormalShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadNormalShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadNormalShiftDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadNormalShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadNormalShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertNormalShiftDto | undefined): Observable<InsertNormalShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertNormalShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertNormalShiftDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertNormalShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertNormalShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateNormalShiftDto | undefined): Observable<UpdateNormalShiftDto> {
        let url_ = this.baseUrl + "/api/services/app/NormalShift/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateNormalShiftDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateNormalShiftDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateNormalShiftDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateNormalShiftDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationLevelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadOrganizationLevelDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadOrganizationLevelDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadOrganizationLevelDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadOrganizationLevelDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadOrganizationLevelDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadOrganizationLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadOrganizationLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadOrganizationLevelDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadOrganizationLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadOrganizationLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateOrganizationLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateOrganizationLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateOrganizationLevelDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateOrganizationLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateOrganizationLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertOrganizationLevelDto | undefined): Observable<InsertOrganizationLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertOrganizationLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertOrganizationLevelDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertOrganizationLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertOrganizationLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOrganizationLevelDto | undefined): Observable<UpdateOrganizationLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationLevel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateOrganizationLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateOrganizationLevelDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateOrganizationLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateOrganizationLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PassportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Passport/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadPassportDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Passport/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPassportDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPassportDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadPassportDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPassportDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadPassportDto> {
        let url_ = this.baseUrl + "/api/services/app/Passport/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPassportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPassportDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadPassportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPassportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertPassportDto | undefined): Observable<InsertPassportDto> {
        let url_ = this.baseUrl + "/api/services/app/Passport/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertPassportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertPassportDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertPassportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertPassportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePassportDto | undefined): Observable<UpdatePassportDto> {
        let url_ = this.baseUrl + "/api/services/app/Passport/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePassportDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePassportDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdatePassportDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePassportDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PositionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Position/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadPositionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPositionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPositionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadPositionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPositionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEmptyPositions(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadPositionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/GetAllEmptyPositions?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEmptyPositions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEmptyPositions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPositionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPositionDtoPagedResultDto>;
        }));
    }

    protected processGetAllEmptyPositions(response: HttpResponseBase): Observable<ReadPositionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPositionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadPositionDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPositionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPositionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadPositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdatePositionDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePositionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePositionDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdatePositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertPositionDto | undefined): Observable<InsertPositionDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertPositionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertPositionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertPositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertPositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePositionDto | undefined): Observable<UpdatePositionDto> {
        let url_ = this.baseUrl + "/api/services/app/Position/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePositionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePositionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdatePositionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePositionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PositionWorkTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadPositionWorkTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPositionWorkTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPositionWorkTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadPositionWorkTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPositionWorkTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadPositionWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPositionWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPositionWorkTypeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadPositionWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPositionWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdatePositionWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePositionWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePositionWorkTypeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdatePositionWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePositionWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertPositionWorkTypeDto | undefined): Observable<InsertPositionWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertPositionWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertPositionWorkTypeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertPositionWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertPositionWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePositionWorkTypeDto | undefined): Observable<UpdatePositionWorkTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/PositionWorkType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePositionWorkTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePositionWorkTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdatePositionWorkTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePositionWorkTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PromotionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadPromotionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPromotionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPromotionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadPromotionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPromotionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadPromotionDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadPromotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadPromotionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadPromotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadPromotionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertPromotionDto | undefined): Observable<InsertPromotionDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertPromotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertPromotionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertPromotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertPromotionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdatePromotionDto | undefined): Observable<UpdatePromotionDto> {
        let url_ = this.baseUrl + "/api/services/app/Promotion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdatePromotionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdatePromotionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdatePromotionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatePromotionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rank/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<RankDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Rank/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RankDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RankDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RankDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<RankDto> {
        let url_ = this.baseUrl + "/api/services/app/Rank/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RankDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<RankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: RankDto | undefined): Observable<RankDto> {
        let url_ = this.baseUrl + "/api/services/app/Rank/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RankDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<RankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RankDto | undefined): Observable<RankDto> {
        let url_ = this.baseUrl + "/api/services/app/Rank/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RankDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RankDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RankDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RankDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ReligionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Religion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReligionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Religion/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReligionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReligionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReligionDto> {
        let url_ = this.baseUrl + "/api/services/app/Religion/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReligionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReligionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: ReligionDto | undefined): Observable<ReligionDto> {
        let url_ = this.baseUrl + "/api/services/app/Religion/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ReligionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReligionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ReligionDto | undefined): Observable<ReligionDto> {
        let url_ = this.baseUrl + "/api/services/app/Religion/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReligionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReligionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ReligionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReligionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ResidencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Residency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadResidencyDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Residency/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadResidencyDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadResidencyDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadResidencyDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadResidencyDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadResidencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Residency/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadResidencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadResidencyDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadResidencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadResidencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertResidencyDto | undefined): Observable<InsertResidencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Residency/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertResidencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertResidencyDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertResidencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertResidencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateResidencyDto | undefined): Observable<UpdateResidencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Residency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateResidencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateResidencyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateResidencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateResidencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ResignationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Resignation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadResignationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Resignation/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadResignationDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadResignationDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadResignationDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadResignationDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadResignationDto> {
        let url_ = this.baseUrl + "/api/services/app/Resignation/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadResignationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadResignationDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadResignationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadResignationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertResignationDto | undefined): Observable<InsertResignationDto> {
        let url_ = this.baseUrl + "/api/services/app/Resignation/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertResignationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertResignationDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertResignationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertResignationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateResignationDto | undefined): Observable<UpdateResignationDto> {
        let url_ = this.baseUrl + "/api/services/app/Resignation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateResignationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateResignationDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateResignationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateResignationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ScoreTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScoreType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ScoreTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ScoreType/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScoreTypeDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScoreTypeDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ScoreTypeDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScoreTypeDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ScoreTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ScoreType/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScoreTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScoreTypeDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ScoreTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScoreTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: ScoreTypeDto | undefined): Observable<ScoreTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ScoreType/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScoreTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScoreTypeDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<ScoreTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScoreTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: ScoreTypeDto | undefined): Observable<ScoreTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/ScoreType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScoreTypeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScoreTypeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ScoreTypeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScoreTypeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SkillServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Skill/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadSkillDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Skill/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadSkillDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadSkillDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadSkillDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadSkillDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadSkillDto> {
        let url_ = this.baseUrl + "/api/services/app/Skill/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadSkillDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadSkillDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadSkillDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadSkillDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertSkillDto | undefined): Observable<InsertSkillDto> {
        let url_ = this.baseUrl + "/api/services/app/Skill/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertSkillDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertSkillDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertSkillDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertSkillDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSkillDto | undefined): Observable<UpdateSkillDto> {
        let url_ = this.baseUrl + "/api/services/app/Skill/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateSkillDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateSkillDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateSkillDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateSkillDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SpouseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadSpouseDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadSpouseDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadSpouseDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadSpouseDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadSpouseDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadSpouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadSpouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadSpouseDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadSpouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadSpouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertSpouseDto | undefined): Observable<InsertSpouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertSpouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertSpouseDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertSpouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertSpouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateSpouseDto | undefined): Observable<UpdateSpouseDto> {
        let url_ = this.baseUrl + "/api/services/app/Spouse/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateSpouseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateSpouseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateSpouseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateSpouseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TemporaryWorkshopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TemporaryWorkshop/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadTemporaryWorkshopDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TemporaryWorkshop/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTemporaryWorkshopDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTemporaryWorkshopDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadTemporaryWorkshopDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTemporaryWorkshopDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadTemporaryWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/TemporaryWorkshop/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTemporaryWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTemporaryWorkshopDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadTemporaryWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTemporaryWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertTemporaryWorkshopDto | undefined): Observable<InsertTemporaryWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/TemporaryWorkshop/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertTemporaryWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertTemporaryWorkshopDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertTemporaryWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertTemporaryWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTemporaryWorkshopDto | undefined): Observable<UpdateTemporaryWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/TemporaryWorkshop/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateTemporaryWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateTemporaryWorkshopDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateTemporaryWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateTemporaryWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TrainingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Training/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadTrainingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTrainingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTrainingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadTrainingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTrainingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadTrainingDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTrainingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTrainingDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadTrainingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTrainingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertTrainingDto | undefined): Observable<InsertTrainingDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertTrainingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertTrainingDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertTrainingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertTrainingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTrainingDto | undefined): Observable<UpdateTrainingDto> {
        let url_ = this.baseUrl + "/api/services/app/Training/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateTrainingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateTrainingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateTrainingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateTrainingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Transfer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadTransferDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Transfer/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTransferDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTransferDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadTransferDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTransferDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/Transfer/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTransferDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertTransferDto | undefined): Observable<InsertTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/Transfer/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertTransferDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTransferDto | undefined): Observable<UpdateTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/Transfer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateTransferDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TravelMissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelMission/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadTravelMissionDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelMission/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTravelMissionDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTravelMissionDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadTravelMissionDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTravelMissionDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadTravelMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelMission/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadTravelMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadTravelMissionDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadTravelMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadTravelMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertTravelMissionDto | undefined): Observable<InsertTravelMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelMission/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertTravelMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertTravelMissionDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertTravelMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertTravelMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTravelMissionDto | undefined): Observable<UpdateTravelMissionDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelMission/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateTravelMissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateTravelMissionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateTravelMissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateTravelMissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UniversityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/University/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<UniversityDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/University/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UniversityDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UniversityDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UniversityDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UniversityDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<UniversityDto> {
        let url_ = this.baseUrl + "/api/services/app/University/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UniversityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UniversityDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<UniversityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UniversityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: UniversityDto | undefined): Observable<UniversityDto> {
        let url_ = this.baseUrl + "/api/services/app/University/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UniversityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UniversityDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<UniversityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UniversityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UniversityDto | undefined): Observable<UniversityDto> {
        let url_ = this.baseUrl + "/api/services/app/University/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UniversityDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UniversityDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UniversityDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UniversityDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeActivate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeActivate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeActivate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WorkflowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Workflow/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadWorkflowDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Workflow/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkflowDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkflowDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadWorkflowDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkflowDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadWorkflowDto> {
        let url_ = this.baseUrl + "/api/services/app/Workflow/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkflowDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadWorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertWorkflowDto | undefined): Observable<InsertWorkflowDto> {
        let url_ = this.baseUrl + "/api/services/app/Workflow/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertWorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertWorkflowDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertWorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertWorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkflowDto | undefined): Observable<UpdateWorkflowDto> {
        let url_ = this.baseUrl + "/api/services/app/Workflow/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateWorkflowDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateWorkflowDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateWorkflowDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateWorkflowDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WorkflowSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadWorkflowSettingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkflowSettingDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkflowSettingDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadWorkflowSettingDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkflowSettingDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadWorkflowSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkflowSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkflowSettingDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadWorkflowSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkflowSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateWorkflowSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateWorkflowSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateWorkflowSettingDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateWorkflowSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateWorkflowSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertWorkflowSettingDto | undefined): Observable<InsertWorkflowSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertWorkflowSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertWorkflowSettingDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertWorkflowSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertWorkflowSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkflowSettingDto | undefined): Observable<UpdateWorkflowSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkflowSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateWorkflowSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateWorkflowSettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateWorkflowSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateWorkflowSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WorkshopServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadWorkshopDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/GetAll?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkshopDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkshopDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ReadWorkshopDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkshopDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param attendanceFormId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllById(attendanceFormId: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<ReadWorkshopDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/GetAllById?";
        if (attendanceFormId === null)
            throw new Error("The parameter 'attendanceFormId' cannot be null.");
        else if (attendanceFormId !== undefined)
            url_ += "attendanceFormId=" + encodeURIComponent("" + attendanceFormId) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkshopDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkshopDtoPagedResultDto>;
        }));
    }

    protected processGetAllById(response: HttpResponseBase): Observable<ReadWorkshopDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkshopDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getbyId(id: string | undefined): Observable<ReadWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/GetbyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetbyId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetbyId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadWorkshopDto>;
        }));
    }

    protected processGetbyId(response: HttpResponseBase): Observable<ReadWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: string | undefined): Observable<UpdateWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateWorkshopDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insert(body: InsertWorkshopDto | undefined): Observable<InsertWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/Insert";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsert(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsert(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertWorkshopDto>;
        }));
    }

    protected processInsert(response: HttpResponseBase): Observable<InsertWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateWorkshopDto | undefined): Observable<UpdateWorkshopDto> {
        let url_ = this.baseUrl + "/api/services/app/Workshop/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateWorkshopDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateWorkshopDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateWorkshopDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateWorkshopDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class Assignment implements IAssignment {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    positionID: string;
    position: Position;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    assigningDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.positionID = _data["positionID"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? EmployeeCard.fromJS(_data["employeeCard"]) : <any>undefined;
            this.assigningDate = _data["assigningDate"] ? moment(_data["assigningDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Assignment {
        data = typeof data === 'object' ? data : {};
        let result = new Assignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["positionID"] = this.positionID;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["assigningDate"] = this.assigningDate ? this.assigningDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): Assignment {
        const json = this.toJSON();
        let result = new Assignment();
        result.init(json);
        return result;
    }
}

export interface IAssignment {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    positionID: string;
    position: Position;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    assigningDate: moment.Moment;
    description: string | undefined;
}

export class Attachment implements IAttachment {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    description: string | undefined;
    filePath: string | undefined;

    constructor(data?: IAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.description = _data["description"];
            this.filePath = _data["filePath"];
        }
    }

    static fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["description"] = this.description;
        data["filePath"] = this.filePath;
        return data;
    }

    clone(): Attachment {
        const json = this.toJSON();
        let result = new Attachment();
        result.init(json);
        return result;
    }
}

export interface IAttachment {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    description: string | undefined;
    filePath: string | undefined;
}

export class AttendanceForm implements IAttendanceForm {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    workshops: Workshop[] | undefined;

    constructor(data?: IAttendanceForm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["workshops"])) {
                this.workshops = [] as any;
                for (let item of _data["workshops"])
                    this.workshops.push(Workshop.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttendanceForm {
        data = typeof data === 'object' ? data : {};
        let result = new AttendanceForm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.workshops)) {
            data["workshops"] = [];
            for (let item of this.workshops)
                data["workshops"].push(item.toJSON());
        }
        return data;
    }

    clone(): AttendanceForm {
        const json = this.toJSON();
        let result = new AttendanceForm();
        result.init(json);
        return result;
    }
}

export interface IAttendanceForm {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    workshops: Workshop[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export enum BloodType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class Certificate implements ICertificate {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: string | undefined;
    cityId: string;
    placeofIssuance: City;
    employeeId: string;
    employee: Employee;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.placeofIssuance = _data["placeofIssuance"] ? City.fromJS(_data["placeofIssuance"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Certificate {
        const json = this.toJSON();
        let result = new Certificate();
        result.init(json);
        return result;
    }
}

export interface ICertificate {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    type: string | undefined;
    cityId: string;
    placeofIssuance: City;
    employeeId: string;
    employee: Employee;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
    attachments: Attachment[] | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class Children implements IChildren {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    spouse: Spouse;
    employeeId: string;
    employee: Employee;
    orderInFamily: number;
    gender: Gender;
    maritialStatus: MaritialStatus;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IChildren) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.spouseId = _data["spouseId"];
            this.spouse = _data["spouse"] ? Spouse.fromJS(_data["spouse"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.orderInFamily = _data["orderInFamily"];
            this.gender = _data["gender"];
            this.maritialStatus = _data["maritialStatus"];
            this.isEmployed = _data["isEmployed"];
            this.isStudying = _data["isStudying"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.disabilityExist = _data["disabilityExist"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? City.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? Nationality.fromJS(_data["nationality"]) : <any>undefined;
            this.residencyNo = _data["residencyNo"];
            this.residencExpireDate = _data["residencExpireDate"] ? moment(_data["residencExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Children {
        data = typeof data === 'object' ? data : {};
        let result = new Children();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["spouseId"] = this.spouseId;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["orderInFamily"] = this.orderInFamily;
        data["gender"] = this.gender;
        data["maritialStatus"] = this.maritialStatus;
        data["isEmployed"] = this.isEmployed;
        data["isStudying"] = this.isStudying;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["disabilityExist"] = this.disabilityExist;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residencyNo"] = this.residencyNo;
        data["residencExpireDate"] = this.residencExpireDate ? this.residencExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Children {
        const json = this.toJSON();
        let result = new Children();
        result.init(json);
        return result;
    }
}

export interface IChildren {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    spouse: Spouse;
    employeeId: string;
    employee: Employee;
    orderInFamily: number;
    gender: Gender;
    maritialStatus: MaritialStatus;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: Attachment[] | undefined;
}

export class City implements ICity {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): City {
        const json = this.toJSON();
        let result = new City();
        result.init(json);
        return result;
    }
}

export interface ICity {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class CityDto implements ICityDto {
    id: string;
    name: string | undefined;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CityDto {
        const json = this.toJSON();
        let result = new CityDto();
        result.init(json);
        return result;
    }
}

export interface ICityDto {
    id: string;
    name: string | undefined;
}

export class CityDtoPagedResultDto implements ICityDtoPagedResultDto {
    items: CityDto[] | undefined;
    totalCount: number;

    constructor(data?: ICityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CityDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICityDtoPagedResultDto {
    items: CityDto[] | undefined;
    totalCount: number;
}

export enum ContractType {
    _0 = 0,
    _1 = 1,
}

export class Conviction implements IConviction {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IConviction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.number = _data["number"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.isConvicted = _data["isConvicted"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Conviction {
        data = typeof data === 'object' ? data : {};
        let result = new Conviction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["isConvicted"] = this.isConvicted;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Conviction {
        const json = this.toJSON();
        let result = new Conviction();
        result.init(json);
        return result;
    }
}

export interface IConviction {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
    attachments: Attachment[] | undefined;
}

export class Country implements ICountry {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class CountryDto implements ICountryDto {
    id: string;
    name: string | undefined;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    id: string;
    name: string | undefined;
}

export class CountryDtoPagedResultDto implements ICountryDtoPagedResultDto {
    items: CountryDto[] | undefined;
    totalCount: number;

    constructor(data?: ICountryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(CountryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CountryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CountryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CountryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDtoPagedResultDto {
    items: CountryDto[] | undefined;
    totalCount: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export enum Currency {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Custodie implements ICustodie {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: ICustodie) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): Custodie {
        data = typeof data === 'object' ? data : {};
        let result = new Custodie();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): Custodie {
        const json = this.toJSON();
        let result = new Custodie();
        result.init(json);
        return result;
    }
}

export interface ICustodie {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class Dependent implements IDependent {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    kinshipType: KinshipType;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IDependent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.kinshipLevel = _data["kinshipLevel"];
            this.kinshipTypeId = _data["kinshipTypeId"];
            this.kinshipType = _data["kinshipType"] ? KinshipType.fromJS(_data["kinshipType"]) : <any>undefined;
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? City.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? Nationality.fromJS(_data["nationality"]) : <any>undefined;
            this.contactNumber = _data["contactNumber"];
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dependent {
        data = typeof data === 'object' ? data : {};
        let result = new Dependent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["kinshipLevel"] = this.kinshipLevel;
        data["kinshipTypeId"] = this.kinshipTypeId;
        data["kinshipType"] = this.kinshipType ? this.kinshipType.toJSON() : <any>undefined;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["contactNumber"] = this.contactNumber;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Dependent {
        const json = this.toJSON();
        let result = new Dependent();
        result.init(json);
        return result;
    }
}

export interface IDependent {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    kinshipType: KinshipType;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: Attachment[] | undefined;
}

export class DriverLicense implements IDriverLicense {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    driverLicenseType: DriverLicenseType;
    placeofIssuanceId: string;
    placeofIssuance: City;
    attachments: Attachment[] | undefined;

    constructor(data?: IDriverLicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.number = _data["number"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.legalCondition = _data["legalCondition"];
            this.driverLicenseTypeId = _data["driverLicenseTypeId"];
            this.driverLicenseType = _data["driverLicenseType"] ? DriverLicenseType.fromJS(_data["driverLicenseType"]) : <any>undefined;
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.placeofIssuance = _data["placeofIssuance"] ? City.fromJS(_data["placeofIssuance"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DriverLicense {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicense();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["legalCondition"] = this.legalCondition;
        data["driverLicenseTypeId"] = this.driverLicenseTypeId;
        data["driverLicenseType"] = this.driverLicenseType ? this.driverLicenseType.toJSON() : <any>undefined;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): DriverLicense {
        const json = this.toJSON();
        let result = new DriverLicense();
        result.init(json);
        return result;
    }
}

export interface IDriverLicense {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    driverLicenseType: DriverLicenseType;
    placeofIssuanceId: string;
    placeofIssuance: City;
    attachments: Attachment[] | undefined;
}

export class DriverLicenseType implements IDriverLicenseType {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IDriverLicenseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DriverLicenseType {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): DriverLicenseType {
        const json = this.toJSON();
        let result = new DriverLicenseType();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenseType {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class DriverLicenseTypeDto implements IDriverLicenseTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IDriverLicenseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DriverLicenseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): DriverLicenseTypeDto {
        const json = this.toJSON();
        let result = new DriverLicenseTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenseTypeDto {
    id: string;
    name: string | undefined;
}

export class DriverLicenseTypeDtoPagedResultDto implements IDriverLicenseTypeDtoPagedResultDto {
    items: DriverLicenseTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IDriverLicenseTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(DriverLicenseTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DriverLicenseTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DriverLicenseTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DriverLicenseTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDriverLicenseTypeDtoPagedResultDto {
    items: DriverLicenseTypeDto[] | undefined;
    totalCount: number;
}

export class Education implements IEducation {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    typeId: string;
    type: EducationType;
    majorId: string;
    major: EducationMajor;
    universityId: string;
    university: University;
    rankId: string;
    rank: Rank;
    scoreTypeId: string;
    scoreType: ScoreType;
    scoreId: string;
    score: Score;
    employeeId: string;
    employee: Employee;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    country: Country;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IEducation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? EducationType.fromJS(_data["type"]) : <any>undefined;
            this.majorId = _data["majorId"];
            this.major = _data["major"] ? EducationMajor.fromJS(_data["major"]) : <any>undefined;
            this.universityId = _data["universityId"];
            this.university = _data["university"] ? University.fromJS(_data["university"]) : <any>undefined;
            this.rankId = _data["rankId"];
            this.rank = _data["rank"] ? Rank.fromJS(_data["rank"]) : <any>undefined;
            this.scoreTypeId = _data["scoreTypeId"];
            this.scoreType = _data["scoreType"] ? ScoreType.fromJS(_data["scoreType"]) : <any>undefined;
            this.scoreId = _data["scoreId"];
            this.score = _data["score"] ? Score.fromJS(_data["score"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.amendmentDocumentNo = _data["amendmentDocumentNo"];
            this.amendmentDocumentDate = _data["amendmentDocumentDate"] ? moment(_data["amendmentDocumentDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Education {
        data = typeof data === 'object' ? data : {};
        let result = new Education();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["majorId"] = this.majorId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["universityId"] = this.universityId;
        data["university"] = this.university ? this.university.toJSON() : <any>undefined;
        data["rankId"] = this.rankId;
        data["rank"] = this.rank ? this.rank.toJSON() : <any>undefined;
        data["scoreTypeId"] = this.scoreTypeId;
        data["scoreType"] = this.scoreType ? this.scoreType.toJSON() : <any>undefined;
        data["scoreId"] = this.scoreId;
        data["score"] = this.score ? this.score.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["amendmentDocumentNo"] = this.amendmentDocumentNo;
        data["amendmentDocumentDate"] = this.amendmentDocumentDate ? this.amendmentDocumentDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Education {
        const json = this.toJSON();
        let result = new Education();
        result.init(json);
        return result;
    }
}

export interface IEducation {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    typeId: string;
    type: EducationType;
    majorId: string;
    major: EducationMajor;
    universityId: string;
    university: University;
    rankId: string;
    rank: Rank;
    scoreTypeId: string;
    scoreType: ScoreType;
    scoreId: string;
    score: Score;
    employeeId: string;
    employee: Employee;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    country: Country;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
    attachments: Attachment[] | undefined;
}

export class EducationGrade implements IEducationGrade {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: Currency;
    description: string | undefined;

    constructor(data?: IEducationGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.order = _data["order"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): EducationGrade {
        data = typeof data === 'object' ? data : {};
        let result = new EducationGrade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["order"] = this.order;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["description"] = this.description;
        return data;
    }

    clone(): EducationGrade {
        const json = this.toJSON();
        let result = new EducationGrade();
        result.init(json);
        return result;
    }
}

export interface IEducationGrade {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: Currency;
    description: string | undefined;
}

export class EducationMajor implements IEducationMajor {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IEducationMajor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EducationMajor {
        data = typeof data === 'object' ? data : {};
        let result = new EducationMajor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): EducationMajor {
        const json = this.toJSON();
        let result = new EducationMajor();
        result.init(json);
        return result;
    }
}

export interface IEducationMajor {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class EducationMajorDto implements IEducationMajorDto {
    id: string;
    name: string | undefined;

    constructor(data?: IEducationMajorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EducationMajorDto {
        data = typeof data === 'object' ? data : {};
        let result = new EducationMajorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): EducationMajorDto {
        const json = this.toJSON();
        let result = new EducationMajorDto();
        result.init(json);
        return result;
    }
}

export interface IEducationMajorDto {
    id: string;
    name: string | undefined;
}

export class EducationMajorDtoPagedResultDto implements IEducationMajorDtoPagedResultDto {
    items: EducationMajorDto[] | undefined;
    totalCount: number;

    constructor(data?: IEducationMajorDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EducationMajorDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EducationMajorDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EducationMajorDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EducationMajorDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EducationMajorDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEducationMajorDtoPagedResultDto {
    items: EducationMajorDto[] | undefined;
    totalCount: number;
}

export class EducationType implements IEducationType {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IEducationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EducationType {
        data = typeof data === 'object' ? data : {};
        let result = new EducationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): EducationType {
        const json = this.toJSON();
        let result = new EducationType();
        result.init(json);
        return result;
    }
}

export interface IEducationType {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class EducationTypeDto implements IEducationTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IEducationTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EducationTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EducationTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): EducationTypeDto {
        const json = this.toJSON();
        let result = new EducationTypeDto();
        result.init(json);
        return result;
    }
}

export interface IEducationTypeDto {
    id: string;
    name: string | undefined;
}

export class EducationTypeDtoPagedResultDto implements IEducationTypeDtoPagedResultDto {
    items: EducationTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IEducationTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(EducationTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): EducationTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new EducationTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): EducationTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new EducationTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IEducationTypeDtoPagedResultDto {
    items: EducationTypeDto[] | undefined;
    totalCount: number;
}

export class Employee implements IEmployee {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    readonly fullName: string | undefined;
    readonly tripleName: string | undefined;
    placeofBirthId: string;
    placeofBirth: City;
    dateofBirth: moment.Moment;
    readonly age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    countryofBirth: Country;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: Gender;
    religionId: string;
    religion: Religion;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    readonly fullNameAr: string | undefined;
    readonly tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    nationality: Nationality;
    secondaryNationalityId: string | undefined;
    secondaryNationality: Nationality;
    maritialStatus: MaritialStatus;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    attachments: Attachment[] | undefined;
    spouse: Spouse[] | undefined;
    children: Children[] | undefined;
    dependents: Dependent[] | undefined;
    educations: Education[] | undefined;
    trainings: Training[] | undefined;
    experiences: Experience[] | undefined;
    skills: Skill[] | undefined;
    languages: Language[] | undefined;
    certificates: Certificate[] | undefined;
    militaryService: MilitaryService[] | undefined;
    passports: Passport[] | undefined;
    driverLicense: DriverLicense[] | undefined;
    convictions: Conviction[] | undefined;
    residences: Residency[] | undefined;
    positions: Position[] | undefined;
    bloodType: BloodType;
    userId: number;
    user: User;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            (<any>this).fullName = _data["fullName"];
            (<any>this).tripleName = _data["tripleName"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? City.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            (<any>this).age = _data["age"];
            this.idNumber = _data["idNumber"];
            this.countryofBirthId = _data["countryofBirthId"];
            this.countryofBirth = _data["countryofBirth"] ? Country.fromJS(_data["countryofBirth"]) : <any>undefined;
            this.personalRecordSource = _data["personalRecordSource"];
            this.civilRecordPlaceAndNumber = _data["civilRecordPlaceAndNumber"];
            this.gender = _data["gender"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? Religion.fromJS(_data["religion"]) : <any>undefined;
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherNameAr = _data["fatherNameAr"];
            this.motherNameAr = _data["motherNameAr"];
            (<any>this).fullNameAr = _data["fullNameAr"];
            (<any>this).tripleNameAr = _data["tripleNameAr"];
            this.placeofBirthAr = _data["placeofBirthAr"];
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? Nationality.fromJS(_data["nationality"]) : <any>undefined;
            this.secondaryNationalityId = _data["secondaryNationalityId"];
            this.secondaryNationality = _data["secondaryNationality"] ? Nationality.fromJS(_data["secondaryNationality"]) : <any>undefined;
            this.maritialStatus = _data["maritialStatus"];
            this.photoPath = _data["photoPath"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.webSite = _data["webSite"];
            this.facebook = _data["facebook"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
            if (Array.isArray(_data["spouse"])) {
                this.spouse = [] as any;
                for (let item of _data["spouse"])
                    this.spouse.push(Spouse.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(Children.fromJS(item));
            }
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents.push(Dependent.fromJS(item));
            }
            if (Array.isArray(_data["educations"])) {
                this.educations = [] as any;
                for (let item of _data["educations"])
                    this.educations.push(Education.fromJS(item));
            }
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings.push(Training.fromJS(item));
            }
            if (Array.isArray(_data["experiences"])) {
                this.experiences = [] as any;
                for (let item of _data["experiences"])
                    this.experiences.push(Experience.fromJS(item));
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills.push(Skill.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages.push(Language.fromJS(item));
            }
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates.push(Certificate.fromJS(item));
            }
            if (Array.isArray(_data["militaryService"])) {
                this.militaryService = [] as any;
                for (let item of _data["militaryService"])
                    this.militaryService.push(MilitaryService.fromJS(item));
            }
            if (Array.isArray(_data["passports"])) {
                this.passports = [] as any;
                for (let item of _data["passports"])
                    this.passports.push(Passport.fromJS(item));
            }
            if (Array.isArray(_data["driverLicense"])) {
                this.driverLicense = [] as any;
                for (let item of _data["driverLicense"])
                    this.driverLicense.push(DriverLicense.fromJS(item));
            }
            if (Array.isArray(_data["convictions"])) {
                this.convictions = [] as any;
                for (let item of _data["convictions"])
                    this.convictions.push(Conviction.fromJS(item));
            }
            if (Array.isArray(_data["residences"])) {
                this.residences = [] as any;
                for (let item of _data["residences"])
                    this.residences.push(Residency.fromJS(item));
            }
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions.push(Position.fromJS(item));
            }
            this.bloodType = _data["bloodType"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["fullName"] = this.fullName;
        data["tripleName"] = this.tripleName;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["idNumber"] = this.idNumber;
        data["countryofBirthId"] = this.countryofBirthId;
        data["countryofBirth"] = this.countryofBirth ? this.countryofBirth.toJSON() : <any>undefined;
        data["personalRecordSource"] = this.personalRecordSource;
        data["civilRecordPlaceAndNumber"] = this.civilRecordPlaceAndNumber;
        data["gender"] = this.gender;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherNameAr"] = this.fatherNameAr;
        data["motherNameAr"] = this.motherNameAr;
        data["fullNameAr"] = this.fullNameAr;
        data["tripleNameAr"] = this.tripleNameAr;
        data["placeofBirthAr"] = this.placeofBirthAr;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["secondaryNationalityId"] = this.secondaryNationalityId;
        data["secondaryNationality"] = this.secondaryNationality ? this.secondaryNationality.toJSON() : <any>undefined;
        data["maritialStatus"] = this.maritialStatus;
        data["photoPath"] = this.photoPath;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["webSite"] = this.webSite;
        data["facebook"] = this.facebook;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.spouse)) {
            data["spouse"] = [];
            for (let item of this.spouse)
                data["spouse"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item.toJSON());
        }
        if (Array.isArray(this.educations)) {
            data["educations"] = [];
            for (let item of this.educations)
                data["educations"].push(item.toJSON());
        }
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        if (Array.isArray(this.experiences)) {
            data["experiences"] = [];
            for (let item of this.experiences)
                data["experiences"].push(item.toJSON());
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (Array.isArray(this.militaryService)) {
            data["militaryService"] = [];
            for (let item of this.militaryService)
                data["militaryService"].push(item.toJSON());
        }
        if (Array.isArray(this.passports)) {
            data["passports"] = [];
            for (let item of this.passports)
                data["passports"].push(item.toJSON());
        }
        if (Array.isArray(this.driverLicense)) {
            data["driverLicense"] = [];
            for (let item of this.driverLicense)
                data["driverLicense"].push(item.toJSON());
        }
        if (Array.isArray(this.convictions)) {
            data["convictions"] = [];
            for (let item of this.convictions)
                data["convictions"].push(item.toJSON());
        }
        if (Array.isArray(this.residences)) {
            data["residences"] = [];
            for (let item of this.residences)
                data["residences"].push(item.toJSON());
        }
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        data["bloodType"] = this.bloodType;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): Employee {
        const json = this.toJSON();
        let result = new Employee();
        result.init(json);
        return result;
    }
}

export interface IEmployee {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    fullName: string | undefined;
    tripleName: string | undefined;
    placeofBirthId: string;
    placeofBirth: City;
    dateofBirth: moment.Moment;
    age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    countryofBirth: Country;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: Gender;
    religionId: string;
    religion: Religion;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    fullNameAr: string | undefined;
    tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    nationality: Nationality;
    secondaryNationalityId: string | undefined;
    secondaryNationality: Nationality;
    maritialStatus: MaritialStatus;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    attachments: Attachment[] | undefined;
    spouse: Spouse[] | undefined;
    children: Children[] | undefined;
    dependents: Dependent[] | undefined;
    educations: Education[] | undefined;
    trainings: Training[] | undefined;
    experiences: Experience[] | undefined;
    skills: Skill[] | undefined;
    languages: Language[] | undefined;
    certificates: Certificate[] | undefined;
    militaryService: MilitaryService[] | undefined;
    passports: Passport[] | undefined;
    driverLicense: DriverLicense[] | undefined;
    convictions: Conviction[] | undefined;
    residences: Residency[] | undefined;
    positions: Position[] | undefined;
    bloodType: BloodType;
    userId: number;
    user: User;
}

export class EmployeeCard implements IEmployeeCard {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    readonly fatherName: string | undefined;
    jobDescriptionId: string | undefined;
    jobDescription: JobDescription;
    positionId: string | undefined;
    position: Position;
    jobTitleId: string | undefined;
    jobTitle: JobTitle;
    gradeId: string | undefined;
    grade: Grade;
    attendanceFormId: string | undefined;
    attendanceForm: AttendanceForm;
    startWorkingDate: moment.Moment;
    endWorkingDate: moment.Moment;
    probationPeriodDate: moment.Moment;
    contractType: ContractType;
    custodies: Custodie[] | undefined;
    assignments: Assignment[] | undefined;
    transfers: Transfer[] | undefined;
    resignations: Resignation[] | undefined;
    promotions: Promotion[] | undefined;
    leaveRequests: LeaveRequest[] | undefined;

    constructor(data?: IEmployeeCard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            (<any>this).fatherName = _data["fatherName"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.jobDescription = _data["jobDescription"] ? JobDescription.fromJS(_data["jobDescription"]) : <any>undefined;
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
            this.attendanceFormId = _data["attendanceFormId"];
            this.attendanceForm = _data["attendanceForm"] ? AttendanceForm.fromJS(_data["attendanceForm"]) : <any>undefined;
            this.startWorkingDate = _data["startWorkingDate"] ? moment(_data["startWorkingDate"].toString()) : <any>undefined;
            this.endWorkingDate = _data["endWorkingDate"] ? moment(_data["endWorkingDate"].toString()) : <any>undefined;
            this.probationPeriodDate = _data["probationPeriodDate"] ? moment(_data["probationPeriodDate"].toString()) : <any>undefined;
            this.contractType = _data["contractType"];
            if (Array.isArray(_data["custodies"])) {
                this.custodies = [] as any;
                for (let item of _data["custodies"])
                    this.custodies.push(Custodie.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments.push(Assignment.fromJS(item));
            }
            if (Array.isArray(_data["transfers"])) {
                this.transfers = [] as any;
                for (let item of _data["transfers"])
                    this.transfers.push(Transfer.fromJS(item));
            }
            if (Array.isArray(_data["resignations"])) {
                this.resignations = [] as any;
                for (let item of _data["resignations"])
                    this.resignations.push(Resignation.fromJS(item));
            }
            if (Array.isArray(_data["promotions"])) {
                this.promotions = [] as any;
                for (let item of _data["promotions"])
                    this.promotions.push(Promotion.fromJS(item));
            }
            if (Array.isArray(_data["leaveRequests"])) {
                this.leaveRequests = [] as any;
                for (let item of _data["leaveRequests"])
                    this.leaveRequests.push(LeaveRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmployeeCard {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeCard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["fatherName"] = this.fatherName;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["jobDescription"] = this.jobDescription ? this.jobDescription.toJSON() : <any>undefined;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["attendanceFormId"] = this.attendanceFormId;
        data["attendanceForm"] = this.attendanceForm ? this.attendanceForm.toJSON() : <any>undefined;
        data["startWorkingDate"] = this.startWorkingDate ? this.startWorkingDate.toISOString() : <any>undefined;
        data["endWorkingDate"] = this.endWorkingDate ? this.endWorkingDate.toISOString() : <any>undefined;
        data["probationPeriodDate"] = this.probationPeriodDate ? this.probationPeriodDate.toISOString() : <any>undefined;
        data["contractType"] = this.contractType;
        if (Array.isArray(this.custodies)) {
            data["custodies"] = [];
            for (let item of this.custodies)
                data["custodies"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        if (Array.isArray(this.transfers)) {
            data["transfers"] = [];
            for (let item of this.transfers)
                data["transfers"].push(item.toJSON());
        }
        if (Array.isArray(this.resignations)) {
            data["resignations"] = [];
            for (let item of this.resignations)
                data["resignations"].push(item.toJSON());
        }
        if (Array.isArray(this.promotions)) {
            data["promotions"] = [];
            for (let item of this.promotions)
                data["promotions"].push(item.toJSON());
        }
        if (Array.isArray(this.leaveRequests)) {
            data["leaveRequests"] = [];
            for (let item of this.leaveRequests)
                data["leaveRequests"].push(item.toJSON());
        }
        return data;
    }

    clone(): EmployeeCard {
        const json = this.toJSON();
        let result = new EmployeeCard();
        result.init(json);
        return result;
    }
}

export interface IEmployeeCard {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    fatherName: string | undefined;
    jobDescriptionId: string | undefined;
    jobDescription: JobDescription;
    positionId: string | undefined;
    position: Position;
    jobTitleId: string | undefined;
    jobTitle: JobTitle;
    gradeId: string | undefined;
    grade: Grade;
    attendanceFormId: string | undefined;
    attendanceForm: AttendanceForm;
    startWorkingDate: moment.Moment;
    endWorkingDate: moment.Moment;
    probationPeriodDate: moment.Moment;
    contractType: ContractType;
    custodies: Custodie[] | undefined;
    assignments: Assignment[] | undefined;
    transfers: Transfer[] | undefined;
    resignations: Resignation[] | undefined;
    promotions: Promotion[] | undefined;
    leaveRequests: LeaveRequest[] | undefined;
}

export class Experience implements IExperience {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IExperience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.jobTitle = _data["jobTitle"];
            this.industry = _data["industry"];
            this.companyName = _data["companyName"];
            this.companyLocation = _data["companyLocation"];
            this.companyWebSite = _data["companyWebSite"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.leaveReason = _data["leaveReason"];
            this.notes = _data["notes"];
            this.referenceFullName = _data["referenceFullName"];
            this.referenceJobTitle = _data["referenceJobTitle"];
            this.referenceContact = _data["referenceContact"];
            this.referenceEmail = _data["referenceEmail"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Experience {
        data = typeof data === 'object' ? data : {};
        let result = new Experience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["jobTitle"] = this.jobTitle;
        data["industry"] = this.industry;
        data["companyName"] = this.companyName;
        data["companyLocation"] = this.companyLocation;
        data["companyWebSite"] = this.companyWebSite;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveReason"] = this.leaveReason;
        data["notes"] = this.notes;
        data["referenceFullName"] = this.referenceFullName;
        data["referenceJobTitle"] = this.referenceJobTitle;
        data["referenceContact"] = this.referenceContact;
        data["referenceEmail"] = this.referenceEmail;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Experience {
        const json = this.toJSON();
        let result = new Experience();
        result.init(json);
        return result;
    }
}

export interface IExperience {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
    attachments: Attachment[] | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export enum Formula {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum Gender {
    _0 = 0,
    _1 = 1,
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class Grade implements IGrade {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    organizationLevelId: string;
    organizationLevel: OrganizationLevel;
    educationGradeId: string;
    educationGrade: EducationGrade;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: Currency;
    gradeCategory: GradeCategory;
    jobTitles: JobTitle[] | undefined;

    constructor(data?: IGrade) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.organizationLevelId = _data["organizationLevelId"];
            this.organizationLevel = _data["organizationLevel"] ? OrganizationLevel.fromJS(_data["organizationLevel"]) : <any>undefined;
            this.educationGradeId = _data["educationGradeId"];
            this.educationGrade = _data["educationGrade"] ? EducationGrade.fromJS(_data["educationGrade"]) : <any>undefined;
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.gradeCategory = _data["gradeCategory"];
            if (Array.isArray(_data["jobTitles"])) {
                this.jobTitles = [] as any;
                for (let item of _data["jobTitles"])
                    this.jobTitles.push(JobTitle.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Grade {
        data = typeof data === 'object' ? data : {};
        let result = new Grade();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["organizationLevelId"] = this.organizationLevelId;
        data["organizationLevel"] = this.organizationLevel ? this.organizationLevel.toJSON() : <any>undefined;
        data["educationGradeId"] = this.educationGradeId;
        data["educationGrade"] = this.educationGrade ? this.educationGrade.toJSON() : <any>undefined;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["gradeCategory"] = this.gradeCategory;
        if (Array.isArray(this.jobTitles)) {
            data["jobTitles"] = [];
            for (let item of this.jobTitles)
                data["jobTitles"].push(item.toJSON());
        }
        return data;
    }

    clone(): Grade {
        const json = this.toJSON();
        let result = new Grade();
        result.init(json);
        return result;
    }
}

export interface IGrade {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    organizationLevelId: string;
    organizationLevel: OrganizationLevel;
    educationGradeId: string;
    educationGrade: EducationGrade;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: Currency;
    gradeCategory: GradeCategory;
    jobTitles: JobTitle[] | undefined;
}

export enum GradeCategory {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum HoursPer {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IEventData implements IIEventData {
    eventTime: moment.Moment;
    eventSource: any | undefined;

    constructor(data?: IIEventData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventTime = _data["eventTime"] ? moment(_data["eventTime"].toString()) : <any>undefined;
            this.eventSource = _data["eventSource"];
        }
    }

    static fromJS(data: any): IEventData {
        data = typeof data === 'object' ? data : {};
        let result = new IEventData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventTime"] = this.eventTime ? this.eventTime.toISOString() : <any>undefined;
        data["eventSource"] = this.eventSource;
        return data;
    }

    clone(): IEventData {
        const json = this.toJSON();
        let result = new IEventData();
        result.init(json);
        return result;
    }
}

export interface IIEventData {
    eventTime: moment.Moment;
    eventSource: any | undefined;
}

export class InsertAssignmentDto implements IInsertAssignmentDto {
    id: string;
    jobTitleId: string;
    positionID: string;
    employeeCardId: string;
    assigningDate: string | undefined;
    description: string | undefined;

    constructor(data?: IInsertAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.positionID = _data["positionID"];
            this.employeeCardId = _data["employeeCardId"];
            this.assigningDate = _data["assigningDate"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["positionID"] = this.positionID;
        data["employeeCardId"] = this.employeeCardId;
        data["assigningDate"] = this.assigningDate;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertAssignmentDto {
        const json = this.toJSON();
        let result = new InsertAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IInsertAssignmentDto {
    id: string;
    jobTitleId: string;
    positionID: string;
    employeeCardId: string;
    assigningDate: string | undefined;
    description: string | undefined;
}

export class InsertAttendanceFormDto implements IInsertAttendanceFormDto {
    id: string;
    name: string | undefined;

    constructor(data?: IInsertAttendanceFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InsertAttendanceFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertAttendanceFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): InsertAttendanceFormDto {
        const json = this.toJSON();
        let result = new InsertAttendanceFormDto();
        result.init(json);
        return result;
    }
}

export interface IInsertAttendanceFormDto {
    id: string;
    name: string | undefined;
}

export class InsertAttendanceMonthlyCardDto implements IInsertAttendanceMonthlyCardDto {
    id: string;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;

    constructor(data?: IInsertAttendanceMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCardId = _data["employeeCardId"];
            this.totalRequiredWorkHours = _data["totalRequiredWorkHours"];
            this.actualTotalWorkHours = _data["actualTotalWorkHours"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): InsertAttendanceMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertAttendanceMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCardId"] = this.employeeCardId;
        data["totalRequiredWorkHours"] = this.totalRequiredWorkHours;
        data["actualTotalWorkHours"] = this.actualTotalWorkHours;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): InsertAttendanceMonthlyCardDto {
        const json = this.toJSON();
        let result = new InsertAttendanceMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IInsertAttendanceMonthlyCardDto {
    id: string;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;
}

export class InsertAttendanceRecordDto implements IInsertAttendanceRecordDto {
    id: string;
    year: number;
    month: number;
    name: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    note: string | undefined;
    isCalculated: boolean;

    constructor(data?: IInsertAttendanceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.name = _data["name"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.note = _data["note"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): InsertAttendanceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertAttendanceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["month"] = this.month;
        data["name"] = this.name;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["note"] = this.note;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): InsertAttendanceRecordDto {
        const json = this.toJSON();
        let result = new InsertAttendanceRecordDto();
        result.init(json);
        return result;
    }
}

export interface IInsertAttendanceRecordDto {
    id: string;
    year: number;
    month: number;
    name: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    note: string | undefined;
    isCalculated: boolean;
}

export class InsertBankDto implements IInsertBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    phoneNumber: string | undefined;

    constructor(data?: IInsertBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nationalityId = _data["nationalityId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): InsertBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nationalityId"] = this.nationalityId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): InsertBankDto {
        const json = this.toJSON();
        let result = new InsertBankDto();
        result.init(json);
        return result;
    }
}

export interface IInsertBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    phoneNumber: string | undefined;
}

export class InsertBankInformationDto implements IInsertBankInformationDto {
    id: string;
    bankId: string;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;

    constructor(data?: IInsertBankInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankId = _data["bankId"];
            this.employeeId = _data["employeeId"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertBankInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertBankInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankId"] = this.bankId;
        data["employeeId"] = this.employeeId;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InsertBankInformationDto {
        const json = this.toJSON();
        let result = new InsertBankInformationDto();
        result.init(json);
        return result;
    }
}

export interface IInsertBankInformationDto {
    id: string;
    bankId: string;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
}

export class InsertBenefitCardDto implements IInsertBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IInsertBenefitCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): InsertBenefitCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertBenefitCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): InsertBenefitCardDto {
        const json = this.toJSON();
        let result = new InsertBenefitCardDto();
        result.init(json);
        return result;
    }
}

export interface IInsertBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class InsertCertificateDto implements IInsertCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;

    constructor(data?: IInsertCertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InsertCertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): InsertCertificateDto {
        const json = this.toJSON();
        let result = new InsertCertificateDto();
        result.init(json);
        return result;
    }
}

export interface IInsertCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
}

export class InsertChangeableHolidayDto implements IInsertChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;

    constructor(data?: IInsertChangeableHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
        }
    }

    static fromJS(data: any): InsertChangeableHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertChangeableHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        return data;
    }

    clone(): InsertChangeableHolidayDto {
        const json = this.toJSON();
        let result = new InsertChangeableHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IInsertChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
}

export class InsertChildrenDto implements IInsertChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;

    constructor(data?: IInsertChildrenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.spouseId = _data["spouseId"];
            this.employeeId = _data["employeeId"];
            this.orderInFamily = _data["orderInFamily"];
            this.gender = _data["gender"];
            this.maritialStatus = _data["maritialStatus"];
            this.isEmployed = _data["isEmployed"];
            this.isStudying = _data["isStudying"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.disabilityExist = _data["disabilityExist"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.residencyNo = _data["residencyNo"];
            this.residencExpireDate = _data["residencExpireDate"] ? moment(_data["residencExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertChildrenDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertChildrenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["spouseId"] = this.spouseId;
        data["employeeId"] = this.employeeId;
        data["orderInFamily"] = this.orderInFamily;
        data["gender"] = this.gender;
        data["maritialStatus"] = this.maritialStatus;
        data["isEmployed"] = this.isEmployed;
        data["isStudying"] = this.isStudying;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["disabilityExist"] = this.disabilityExist;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["residencyNo"] = this.residencyNo;
        data["residencExpireDate"] = this.residencExpireDate ? this.residencExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InsertChildrenDto {
        const json = this.toJSON();
        let result = new InsertChildrenDto();
        result.init(json);
        return result;
    }
}

export interface IInsertChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
}

export class InsertCompanyHolidayDto implements IInsertCompanyHolidayDto {
    id: string;
    dayOfWeek: number;

    constructor(data?: IInsertCompanyHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dayOfWeek = _data["dayOfWeek"];
        }
    }

    static fromJS(data: any): InsertCompanyHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCompanyHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dayOfWeek"] = this.dayOfWeek;
        return data;
    }

    clone(): InsertCompanyHolidayDto {
        const json = this.toJSON();
        let result = new InsertCompanyHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IInsertCompanyHolidayDto {
    id: string;
    dayOfWeek: number;
}

export class InsertConvictionDto implements IInsertConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;

    constructor(data?: IInsertConvictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.isConvicted = _data["isConvicted"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InsertConvictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertConvictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["isConvicted"] = this.isConvicted;
        data["notes"] = this.notes;
        return data;
    }

    clone(): InsertConvictionDto {
        const json = this.toJSON();
        let result = new InsertConvictionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
}

export class InsertCustodieDto implements IInsertCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: IInsertCustodieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InsertCustodieDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCustodieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): InsertCustodieDto {
        const json = this.toJSON();
        let result = new InsertCustodieDto();
        result.init(json);
        return result;
    }
}

export interface IInsertCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class InsertDeductionCardDto implements IInsertDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IInsertDeductionCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): InsertDeductionCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertDeductionCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): InsertDeductionCardDto {
        const json = this.toJSON();
        let result = new InsertDeductionCardDto();
        result.init(json);
        return result;
    }
}

export interface IInsertDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class InsertDependentDto implements IInsertDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;

    constructor(data?: IInsertDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.kinshipLevel = _data["kinshipLevel"];
            this.kinshipTypeId = _data["kinshipTypeId"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.contactNumber = _data["contactNumber"];
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["kinshipLevel"] = this.kinshipLevel;
        data["kinshipTypeId"] = this.kinshipTypeId;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["contactNumber"] = this.contactNumber;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InsertDependentDto {
        const json = this.toJSON();
        let result = new InsertDependentDto();
        result.init(json);
        return result;
    }
}

export interface IInsertDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
}

export class InsertDriverLicenseDto implements IInsertDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    placeofIssuanceId: string;

    constructor(data?: IInsertDriverLicenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.legalCondition = _data["legalCondition"];
            this.driverLicenseTypeId = _data["driverLicenseTypeId"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
        }
    }

    static fromJS(data: any): InsertDriverLicenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertDriverLicenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["legalCondition"] = this.legalCondition;
        data["driverLicenseTypeId"] = this.driverLicenseTypeId;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        return data;
    }

    clone(): InsertDriverLicenseDto {
        const json = this.toJSON();
        let result = new InsertDriverLicenseDto();
        result.init(json);
        return result;
    }
}

export interface IInsertDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    placeofIssuanceId: string;
}

export class InsertEducationDto implements IInsertEducationDto {
    id: string;
    typeId: string;
    majorId: string;
    universityId: string;
    rankId: string;
    scoreTypeId: string;
    scoreId: string;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;

    constructor(data?: IInsertEducationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.majorId = _data["majorId"];
            this.universityId = _data["universityId"];
            this.rankId = _data["rankId"];
            this.scoreTypeId = _data["scoreTypeId"];
            this.scoreId = _data["scoreId"];
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.amendmentDocumentNo = _data["amendmentDocumentNo"];
            this.amendmentDocumentDate = _data["amendmentDocumentDate"] ? moment(_data["amendmentDocumentDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): InsertEducationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertEducationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["majorId"] = this.majorId;
        data["universityId"] = this.universityId;
        data["rankId"] = this.rankId;
        data["scoreTypeId"] = this.scoreTypeId;
        data["scoreId"] = this.scoreId;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["amendmentDocumentNo"] = this.amendmentDocumentNo;
        data["amendmentDocumentDate"] = this.amendmentDocumentDate ? this.amendmentDocumentDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        return data;
    }

    clone(): InsertEducationDto {
        const json = this.toJSON();
        let result = new InsertEducationDto();
        result.init(json);
        return result;
    }
}

export interface IInsertEducationDto {
    id: string;
    typeId: string;
    majorId: string;
    universityId: string;
    rankId: string;
    scoreTypeId: string;
    scoreId: string;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
}

export class InsertEducationGradeDto implements IInsertEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;

    constructor(data?: IInsertEducationGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertEducationGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertEducationGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertEducationGradeDto {
        const json = this.toJSON();
        let result = new InsertEducationGradeDto();
        result.init(json);
        return result;
    }
}

export interface IInsertEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;
}

export class InsertEmployeeDto implements IInsertEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    readonly fullName: string | undefined;
    readonly tripleName: string | undefined;
    placeofBirthId: string;
    dateofBirth: string | undefined;
    readonly age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    readonly fullNameAr: string | undefined;
    readonly tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    secondaryNationalityId: string | undefined;
    maritialStatus: number;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    bloodType: number;

    constructor(data?: IInsertEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            (<any>this).fullName = _data["fullName"];
            (<any>this).tripleName = _data["tripleName"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.dateofBirth = _data["dateofBirth"];
            (<any>this).age = _data["age"];
            this.idNumber = _data["idNumber"];
            this.countryofBirthId = _data["countryofBirthId"];
            this.personalRecordSource = _data["personalRecordSource"];
            this.civilRecordPlaceAndNumber = _data["civilRecordPlaceAndNumber"];
            this.gender = _data["gender"];
            this.religionId = _data["religionId"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherNameAr = _data["fatherNameAr"];
            this.motherNameAr = _data["motherNameAr"];
            (<any>this).fullNameAr = _data["fullNameAr"];
            (<any>this).tripleNameAr = _data["tripleNameAr"];
            this.placeofBirthAr = _data["placeofBirthAr"];
            this.nationalityId = _data["nationalityId"];
            this.secondaryNationalityId = _data["secondaryNationalityId"];
            this.maritialStatus = _data["maritialStatus"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.webSite = _data["webSite"];
            this.facebook = _data["facebook"];
            this.bloodType = _data["bloodType"];
        }
    }

    static fromJS(data: any): InsertEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["fullName"] = this.fullName;
        data["tripleName"] = this.tripleName;
        data["placeofBirthId"] = this.placeofBirthId;
        data["dateofBirth"] = this.dateofBirth;
        data["age"] = this.age;
        data["idNumber"] = this.idNumber;
        data["countryofBirthId"] = this.countryofBirthId;
        data["personalRecordSource"] = this.personalRecordSource;
        data["civilRecordPlaceAndNumber"] = this.civilRecordPlaceAndNumber;
        data["gender"] = this.gender;
        data["religionId"] = this.religionId;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherNameAr"] = this.fatherNameAr;
        data["motherNameAr"] = this.motherNameAr;
        data["fullNameAr"] = this.fullNameAr;
        data["tripleNameAr"] = this.tripleNameAr;
        data["placeofBirthAr"] = this.placeofBirthAr;
        data["nationalityId"] = this.nationalityId;
        data["secondaryNationalityId"] = this.secondaryNationalityId;
        data["maritialStatus"] = this.maritialStatus;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["webSite"] = this.webSite;
        data["facebook"] = this.facebook;
        data["bloodType"] = this.bloodType;
        return data;
    }

    clone(): InsertEmployeeDto {
        const json = this.toJSON();
        let result = new InsertEmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IInsertEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    fullName: string | undefined;
    tripleName: string | undefined;
    placeofBirthId: string;
    dateofBirth: string | undefined;
    age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    fullNameAr: string | undefined;
    tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    secondaryNationalityId: string | undefined;
    maritialStatus: number;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    bloodType: number;
}

export class InsertEntranceExitRecordDto implements IInsertEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    employeeId: string;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;

    constructor(data?: IInsertEntranceExitRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.logDate = _data["logDate"];
            this.employeeId = _data["employeeId"];
            this.logTime = _data["logTime"];
            this.recordType = _data["recordType"];
            this.notes = _data["notes"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): InsertEntranceExitRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertEntranceExitRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["logDate"] = this.logDate;
        data["employeeId"] = this.employeeId;
        data["logTime"] = this.logTime;
        data["recordType"] = this.recordType;
        data["notes"] = this.notes;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): InsertEntranceExitRecordDto {
        const json = this.toJSON();
        let result = new InsertEntranceExitRecordDto();
        result.init(json);
        return result;
    }
}

export interface IInsertEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    employeeId: string;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;
}

export class InsertExperienceDto implements IInsertExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;

    constructor(data?: IInsertExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.jobTitle = _data["jobTitle"];
            this.industry = _data["industry"];
            this.companyName = _data["companyName"];
            this.companyLocation = _data["companyLocation"];
            this.companyWebSite = _data["companyWebSite"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.leaveReason = _data["leaveReason"];
            this.notes = _data["notes"];
            this.referenceFullName = _data["referenceFullName"];
            this.referenceJobTitle = _data["referenceJobTitle"];
            this.referenceContact = _data["referenceContact"];
            this.referenceEmail = _data["referenceEmail"];
        }
    }

    static fromJS(data: any): InsertExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["jobTitle"] = this.jobTitle;
        data["industry"] = this.industry;
        data["companyName"] = this.companyName;
        data["companyLocation"] = this.companyLocation;
        data["companyWebSite"] = this.companyWebSite;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveReason"] = this.leaveReason;
        data["notes"] = this.notes;
        data["referenceFullName"] = this.referenceFullName;
        data["referenceJobTitle"] = this.referenceJobTitle;
        data["referenceContact"] = this.referenceContact;
        data["referenceEmail"] = this.referenceEmail;
        return data;
    }

    clone(): InsertExperienceDto {
        const json = this.toJSON();
        let result = new InsertExperienceDto();
        result.init(json);
        return result;
    }
}

export interface IInsertExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
}

export class InsertFinancialCardDto implements IInsertFinancialCardDto {
    id: string;
    employeeId: string;
    salary: number;

    constructor(data?: IInsertFinancialCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.salary = _data["salary"];
        }
    }

    static fromJS(data: any): InsertFinancialCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFinancialCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["salary"] = this.salary;
        return data;
    }

    clone(): InsertFinancialCardDto {
        const json = this.toJSON();
        let result = new InsertFinancialCardDto();
        result.init(json);
        return result;
    }
}

export interface IInsertFinancialCardDto {
    id: string;
    employeeId: string;
    salary: number;
}

export class InsertFixedHolidayDto implements IInsertFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;

    constructor(data?: IInsertFixedHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.numberofDays = _data["numberofDays"];
        }
    }

    static fromJS(data: any): InsertFixedHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertFixedHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["day"] = this.day;
        data["month"] = this.month;
        data["numberofDays"] = this.numberofDays;
        return data;
    }

    clone(): InsertFixedHolidayDto {
        const json = this.toJSON();
        let result = new InsertFixedHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IInsertFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;
}

export class InsertGradeDto implements IInsertGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    educationGradeId: string;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;

    constructor(data?: IInsertGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationLevelId = _data["organizationLevelId"];
            this.educationGradeId = _data["educationGradeId"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.gradeCategory = _data["gradeCategory"];
        }
    }

    static fromJS(data: any): InsertGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationLevelId"] = this.organizationLevelId;
        data["educationGradeId"] = this.educationGradeId;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["gradeCategory"] = this.gradeCategory;
        return data;
    }

    clone(): InsertGradeDto {
        const json = this.toJSON();
        let result = new InsertGradeDto();
        result.init(json);
        return result;
    }
}

export interface IInsertGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    educationGradeId: string;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;
}

export class InsertHourlyMissionDto implements IInsertHourlyMissionDto {
    id: string;
    employeeId: string;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IInsertHourlyMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InsertHourlyMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertHourlyMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): InsertHourlyMissionDto {
        const json = this.toJSON();
        let result = new InsertHourlyMissionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertHourlyMissionDto {
    id: string;
    employeeId: string;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class InsertJobDescriptionDto implements IInsertJobDescriptionDto {
    id: string;
    jobTitleId: string;
    name: string | undefined;
    nodeId: string;
    description: string | undefined;

    constructor(data?: IInsertJobDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.name = _data["name"];
            this.nodeId = _data["nodeId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertJobDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertJobDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["name"] = this.name;
        data["nodeId"] = this.nodeId;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertJobDescriptionDto {
        const json = this.toJSON();
        let result = new InsertJobDescriptionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertJobDescriptionDto {
    id: string;
    jobTitleId: string;
    name: string | undefined;
    nodeId: string;
    description: string | undefined;
}

export class InsertJobTitleDto implements IInsertJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;

    constructor(data?: IInsertJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.gradeId = _data["gradeId"];
        }
    }

    static fromJS(data: any): InsertJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["gradeId"] = this.gradeId;
        return data;
    }

    clone(): InsertJobTitleDto {
        const json = this.toJSON();
        let result = new InsertJobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IInsertJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
}

export class InsertLanguageDto implements IInsertLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    writingId: string;
    readingId: string;
    speakingId: string;
    listeningId: string;

    constructor(data?: IInsertLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.languageNameId = _data["languageNameId"];
            this.writingId = _data["writingId"];
            this.readingId = _data["readingId"];
            this.speakingId = _data["speakingId"];
            this.listeningId = _data["listeningId"];
        }
    }

    static fromJS(data: any): InsertLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["languageNameId"] = this.languageNameId;
        data["writingId"] = this.writingId;
        data["readingId"] = this.readingId;
        data["speakingId"] = this.speakingId;
        data["listeningId"] = this.listeningId;
        return data;
    }

    clone(): InsertLanguageDto {
        const json = this.toJSON();
        let result = new InsertLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IInsertLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    writingId: string;
    readingId: string;
    speakingId: string;
    listeningId: string;
}

export class InsertLeaveRequestDto implements IInsertLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    employeeId: string;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    readonly leaveRequestBalance: number;
    description: string | undefined;

    constructor(data?: IInsertLeaveRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.leaveSettingId = _data["leaveSettingId"];
            this.employeeId = _data["employeeId"];
            this.requestDate = _data["requestDate"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.isHourly = _data["isHourly"];
            this.startHour = _data["startHour"];
            this.endHour = _data["endHour"];
            (<any>this).leaveRequestBalance = _data["leaveRequestBalance"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertLeaveRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertLeaveRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["leaveSettingId"] = this.leaveSettingId;
        data["employeeId"] = this.employeeId;
        data["requestDate"] = this.requestDate;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["isHourly"] = this.isHourly;
        data["startHour"] = this.startHour;
        data["endHour"] = this.endHour;
        data["leaveRequestBalance"] = this.leaveRequestBalance;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertLeaveRequestDto {
        const json = this.toJSON();
        let result = new InsertLeaveRequestDto();
        result.init(json);
        return result;
    }
}

export interface IInsertLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    employeeId: string;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    leaveRequestBalance: number;
    description: string | undefined;
}

export class InsertLeaveSettingDto implements IInsertLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    description: string | undefined;

    constructor(data?: IInsertLeaveSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.isPaidLeave = _data["isPaidLeave"];
            this.workflowSettingId = _data["workflowSettingId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertLeaveSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertLeaveSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["isPaidLeave"] = this.isPaidLeave;
        data["workflowSettingId"] = this.workflowSettingId;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertLeaveSettingDto {
        const json = this.toJSON();
        let result = new InsertLeaveSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInsertLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    description: string | undefined;
}

export class InsertMilitaryServiceDto implements IInsertMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: IInsertMilitaryServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.militaryStatus = _data["militaryStatus"];
            this.isPermanentExemption = _data["isPermanentExemption"];
            this.exemptionReason = _data["exemptionReason"];
            this.exemptionDate = _data["exemptionDate"] ? moment(_data["exemptionDate"].toString()) : <any>undefined;
            this.delayReason = _data["delayReason"];
            this.delayDate = _data["delayDate"] ? moment(_data["delayDate"].toString()) : <any>undefined;
            this.militaryServiceNo = _data["militaryServiceNo"];
            this.militaryServiceDocIssueDate = _data["militaryServiceDocIssueDate"] ? moment(_data["militaryServiceDocIssueDate"].toString()) : <any>undefined;
            this.granter = _data["granter"];
            this.years = _data["years"];
            this.months = _data["months"];
            this.days = _data["days"];
            this.serviceStartDate = _data["serviceStartDate"] ? moment(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? moment(_data["serviceEndDate"].toString()) : <any>undefined;
            this.holdDate = _data["holdDate"] ? moment(_data["holdDate"].toString()) : <any>undefined;
            this.reserveStartDate = _data["reserveStartDate"] ? moment(_data["reserveStartDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InsertMilitaryServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertMilitaryServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["militaryStatus"] = this.militaryStatus;
        data["isPermanentExemption"] = this.isPermanentExemption;
        data["exemptionReason"] = this.exemptionReason;
        data["exemptionDate"] = this.exemptionDate ? this.exemptionDate.toISOString() : <any>undefined;
        data["delayReason"] = this.delayReason;
        data["delayDate"] = this.delayDate ? this.delayDate.toISOString() : <any>undefined;
        data["militaryServiceNo"] = this.militaryServiceNo;
        data["militaryServiceDocIssueDate"] = this.militaryServiceDocIssueDate ? this.militaryServiceDocIssueDate.toISOString() : <any>undefined;
        data["granter"] = this.granter;
        data["years"] = this.years;
        data["months"] = this.months;
        data["days"] = this.days;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toISOString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toISOString() : <any>undefined;
        data["holdDate"] = this.holdDate ? this.holdDate.toISOString() : <any>undefined;
        data["reserveStartDate"] = this.reserveStartDate ? this.reserveStartDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): InsertMilitaryServiceDto {
        const json = this.toJSON();
        let result = new InsertMilitaryServiceDto();
        result.init(json);
        return result;
    }
}

export interface IInsertMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class InsertMonthDto implements IInsertMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;

    constructor(data?: IInsertMonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.monthName = _data["monthName"];
            this.title = _data["title"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): InsertMonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertMonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["monthName"] = this.monthName;
        data["title"] = this.title;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): InsertMonthDto {
        const json = this.toJSON();
        let result = new InsertMonthDto();
        result.init(json);
        return result;
    }
}

export interface IInsertMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;
}

export class InsertMonthlyCardDto implements IInsertMonthlyCardDto {
    id: string;
    employeeCardId: string;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;

    constructor(data?: IInsertMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCardId = _data["employeeCardId"];
            this.salary = _data["salary"];
            this.calculated = _data["calculated"];
            this.workDays = _data["workDays"];
            this.totalDeductions = _data["totalDeductions"];
            this.totalBenefits = _data["totalBenefits"];
            this.finalSalary = _data["finalSalary"];
        }
    }

    static fromJS(data: any): InsertMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCardId"] = this.employeeCardId;
        data["salary"] = this.salary;
        data["calculated"] = this.calculated;
        data["workDays"] = this.workDays;
        data["totalDeductions"] = this.totalDeductions;
        data["totalBenefits"] = this.totalBenefits;
        data["finalSalary"] = this.finalSalary;
        return data;
    }

    clone(): InsertMonthlyCardDto {
        const json = this.toJSON();
        let result = new InsertMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IInsertMonthlyCardDto {
    id: string;
    employeeCardId: string;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;
}

export class InsertNodeDto implements IInsertNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    code: string | undefined;
    isRoot: boolean;

    constructor(data?: IInsertNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.isRoot = _data["isRoot"];
        }
    }

    static fromJS(data: any): InsertNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["isRoot"] = this.isRoot;
        return data;
    }

    clone(): InsertNodeDto {
        const json = this.toJSON();
        let result = new InsertNodeDto();
        result.init(json);
        return result;
    }
}

export interface IInsertNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    code: string | undefined;
    isRoot: boolean;
}

export class InsertNormalShiftDto implements IInsertNormalShiftDto {
    id: string;
    entryTime: string | undefined;
    workshopId: string;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;

    constructor(data?: IInsertNormalShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entryTime = _data["entryTime"];
            this.workshopId = _data["workshopId"];
            this.exitTime = _data["exitTime"];
            this.shiftRangeStartTime = _data["shiftRangeStartTime"];
            this.shiftRangeEndTime = _data["shiftRangeEndTime"];
        }
    }

    static fromJS(data: any): InsertNormalShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertNormalShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entryTime"] = this.entryTime;
        data["workshopId"] = this.workshopId;
        data["exitTime"] = this.exitTime;
        data["shiftRangeStartTime"] = this.shiftRangeStartTime;
        data["shiftRangeEndTime"] = this.shiftRangeEndTime;
        return data;
    }

    clone(): InsertNormalShiftDto {
        const json = this.toJSON();
        let result = new InsertNormalShiftDto();
        result.init(json);
        return result;
    }
}

export interface IInsertNormalShiftDto {
    id: string;
    entryTime: string | undefined;
    workshopId: string;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;
}

export class InsertOrganizationLevelDto implements IInsertOrganizationLevelDto {
    id: string;
    name: string | undefined;

    constructor(data?: IInsertOrganizationLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InsertOrganizationLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrganizationLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): InsertOrganizationLevelDto {
        const json = this.toJSON();
        let result = new InsertOrganizationLevelDto();
        result.init(json);
        return result;
    }
}

export interface IInsertOrganizationLevelDto {
    id: string;
    name: string | undefined;
}

export class InsertPassportDto implements IInsertPassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;

    constructor(data?: IInsertPassportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertPassportDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertPassportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InsertPassportDto {
        const json = this.toJSON();
        let result = new InsertPassportDto();
        result.init(json);
        return result;
    }
}

export interface IInsertPassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
}

export class InsertPositionDto implements IInsertPositionDto {
    id: string;
    jobDescriptionId: string;
    positionWorkTypeId: string;
    workingHours: number;
    per: number;
    hasManager: boolean;
    managerId: string | undefined;

    constructor(data?: IInsertPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.positionWorkTypeId = _data["positionWorkTypeId"];
            this.workingHours = _data["workingHours"];
            this.per = _data["per"];
            this.hasManager = _data["hasManager"];
            this.managerId = _data["managerId"];
        }
    }

    static fromJS(data: any): InsertPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["positionWorkTypeId"] = this.positionWorkTypeId;
        data["workingHours"] = this.workingHours;
        data["per"] = this.per;
        data["hasManager"] = this.hasManager;
        data["managerId"] = this.managerId;
        return data;
    }

    clone(): InsertPositionDto {
        const json = this.toJSON();
        let result = new InsertPositionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertPositionDto {
    id: string;
    jobDescriptionId: string;
    positionWorkTypeId: string;
    workingHours: number;
    per: number;
    hasManager: boolean;
    managerId: string | undefined;
}

export class InsertPositionWorkTypeDto implements IInsertPositionWorkTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IInsertPositionWorkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InsertPositionWorkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertPositionWorkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): InsertPositionWorkTypeDto {
        const json = this.toJSON();
        let result = new InsertPositionWorkTypeDto();
        result.init(json);
        return result;
    }
}

export interface IInsertPositionWorkTypeDto {
    id: string;
    name: string | undefined;
}

export class InsertPromotionDto implements IInsertPromotionDto {
    id: string;
    jobTitleId: string;
    positionId: string;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IInsertPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.positionId = _data["positionId"];
            this.employeeCardId = _data["employeeCardId"];
            this.promotionDate = _data["promotionDate"] ? moment(_data["promotionDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["positionId"] = this.positionId;
        data["employeeCardId"] = this.employeeCardId;
        data["promotionDate"] = this.promotionDate ? this.promotionDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertPromotionDto {
        const json = this.toJSON();
        let result = new InsertPromotionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertPromotionDto {
    id: string;
    jobTitleId: string;
    positionId: string;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;
}

export class InsertResidencyDto implements IInsertResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;

    constructor(data?: IInsertResidencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.residencyType = _data["residencyType"];
            this.nationalityId = _data["nationalityId"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.tel = _data["tel"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): InsertResidencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertResidencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["residencyType"] = this.residencyType;
        data["nationalityId"] = this.nationalityId;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        return data;
    }

    clone(): InsertResidencyDto {
        const json = this.toJSON();
        let result = new InsertResidencyDto();
        result.init(json);
        return result;
    }
}

export interface IInsertResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
}

export class InsertResignationDto implements IInsertResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    description: string | undefined;

    constructor(data?: IInsertResignationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resignationDate = _data["resignationDate"] ? moment(_data["resignationDate"].toString()) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertResignationDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertResignationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resignationDate"] = this.resignationDate ? this.resignationDate.toISOString() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertResignationDto {
        const json = this.toJSON();
        let result = new InsertResignationDto();
        result.init(json);
        return result;
    }
}

export interface IInsertResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    description: string | undefined;
}

export class InsertSkillDto implements IInsertSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    description: string | undefined;
    comments: string | undefined;

    constructor(data?: IInsertSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.skillName = _data["skillName"];
            this.levelId = _data["levelId"];
            this.description = _data["description"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): InsertSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["skillName"] = this.skillName;
        data["levelId"] = this.levelId;
        data["description"] = this.description;
        data["comments"] = this.comments;
        return data;
    }

    clone(): InsertSkillDto {
        const json = this.toJSON();
        let result = new InsertSkillDto();
        result.init(json);
        return result;
    }
}

export interface IInsertSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    description: string | undefined;
    comments: string | undefined;
}

export class InsertSpouseDto implements IInsertSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;

    constructor(data?: IInsertSpouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.residencyNo = _data["residencyNo"];
            this.residencyExpireDate = _data["residencyExpireDate"] ? moment(_data["residencyExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.firstContactNumber = _data["firstContactNumber"];
            this.secondContactNumber = _data["secondContactNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.gender = _data["gender"];
            this.order = _data["order"];
            this.marrigeDate = _data["marrigeDate"] ? moment(_data["marrigeDate"].toString()) : <any>undefined;
            this.isDivorced = _data["isDivorced"];
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            this.hasJob = _data["hasJob"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.workAddress = _data["workAddress"];
            this.workPhone = _data["workPhone"];
            this.workEmail = _data["workEmail"];
        }
    }

    static fromJS(data: any): InsertSpouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertSpouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["residencyNo"] = this.residencyNo;
        data["residencyExpireDate"] = this.residencyExpireDate ? this.residencyExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["firstContactNumber"] = this.firstContactNumber;
        data["secondContactNumber"] = this.secondContactNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["gender"] = this.gender;
        data["order"] = this.order;
        data["marrigeDate"] = this.marrigeDate ? this.marrigeDate.toISOString() : <any>undefined;
        data["isDivorced"] = this.isDivorced;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        data["hasJob"] = this.hasJob;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["workAddress"] = this.workAddress;
        data["workPhone"] = this.workPhone;
        data["workEmail"] = this.workEmail;
        return data;
    }

    clone(): InsertSpouseDto {
        const json = this.toJSON();
        let result = new InsertSpouseDto();
        result.init(json);
        return result;
    }
}

export interface IInsertSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
}

export class InsertTemporaryWorkshopDto implements IInsertTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;

    constructor(data?: IInsertTemporaryWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workshopId = _data["workshopId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.tempWorkshopId = _data["tempWorkshopId"];
        }
    }

    static fromJS(data: any): InsertTemporaryWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTemporaryWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workshopId"] = this.workshopId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["tempWorkshopId"] = this.tempWorkshopId;
        return data;
    }

    clone(): InsertTemporaryWorkshopDto {
        const json = this.toJSON();
        let result = new InsertTemporaryWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;
}

export class InsertTrainingDto implements IInsertTrainingDto {
    id: string;

    constructor(data?: IInsertTrainingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InsertTrainingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTrainingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): InsertTrainingDto {
        const json = this.toJSON();
        let result = new InsertTrainingDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTrainingDto {
    id: string;
}

export class InsertTransferDto implements IInsertTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationPositionId: string;
    startingDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IInsertTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.destinationJobTitleId = _data["destinationJobTitleId"];
            this.destinationPositionId = _data["destinationPositionId"];
            this.startingDate = _data["startingDate"] ? moment(_data["startingDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["destinationJobTitleId"] = this.destinationJobTitleId;
        data["destinationPositionId"] = this.destinationPositionId;
        data["startingDate"] = this.startingDate ? this.startingDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): InsertTransferDto {
        const json = this.toJSON();
        let result = new InsertTransferDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationPositionId: string;
    startingDate: moment.Moment;
    description: string | undefined;
}

export class InsertTravelMissionDto implements IInsertTravelMissionDto {
    id: string;
    employeeId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IInsertTravelMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InsertTravelMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTravelMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): InsertTravelMissionDto {
        const json = this.toJSON();
        let result = new InsertTravelMissionDto();
        result.init(json);
        return result;
    }
}

export interface IInsertTravelMissionDto {
    id: string;
    employeeId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class InsertWorkflowDto implements IInsertWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    firstUserId: number;
    currentUserId: number;
    targetUserId: number;

    constructor(data?: IInsertWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.creatorId = _data["creatorId"];
            this.firstUserId = _data["firstUserId"];
            this.currentUserId = _data["currentUserId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): InsertWorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["description"] = this.description;
        data["status"] = this.status;
        data["type"] = this.type;
        data["creatorId"] = this.creatorId;
        data["firstUserId"] = this.firstUserId;
        data["currentUserId"] = this.currentUserId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }

    clone(): InsertWorkflowDto {
        const json = this.toJSON();
        let result = new InsertWorkflowDto();
        result.init(json);
        return result;
    }
}

export interface IInsertWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    firstUserId: number;
    currentUserId: number;
    targetUserId: number;
}

export class InsertWorkflowSettingDto implements IInsertWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;

    constructor(data?: IInsertWorkflowSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.steps = _data["steps"];
        }
    }

    static fromJS(data: any): InsertWorkflowSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWorkflowSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["steps"] = this.steps;
        return data;
    }

    clone(): InsertWorkflowSettingDto {
        const json = this.toJSON();
        let result = new InsertWorkflowSettingDto();
        result.init(json);
        return result;
    }
}

export interface IInsertWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;
}

export class InsertWorkshopDto implements IInsertWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;

    constructor(data?: IInsertWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.attendanceFormId = _data["attendanceFormId"];
        }
    }

    static fromJS(data: any): InsertWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsertWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["attendanceFormId"] = this.attendanceFormId;
        return data;
    }

    clone(): InsertWorkshopDto {
        const json = this.toJSON();
        let result = new InsertWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IInsertWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;
}

export class Int64EntityDto implements IInt64EntityDto {
    id: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class JobDescription implements IJobDescription {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    name: string | undefined;
    nodeId: string;
    node: Node;
    description: string | undefined;

    constructor(data?: IJobDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.name = _data["name"];
            this.nodeId = _data["nodeId"];
            this.node = _data["node"] ? Node.fromJS(_data["node"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): JobDescription {
        data = typeof data === 'object' ? data : {};
        let result = new JobDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["nodeId"] = this.nodeId;
        data["node"] = this.node ? this.node.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): JobDescription {
        const json = this.toJSON();
        let result = new JobDescription();
        result.init(json);
        return result;
    }
}

export interface IJobDescription {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    name: string | undefined;
    nodeId: string;
    node: Node;
    description: string | undefined;
}

export class JobTitle implements IJobTitle {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
    grade: Grade;

    constructor(data?: IJobTitle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.order = _data["order"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"] ? Grade.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobTitle {
        data = typeof data === 'object' ? data : {};
        let result = new JobTitle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["order"] = this.order;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        return data;
    }

    clone(): JobTitle {
        const json = this.toJSON();
        let result = new JobTitle();
        result.init(json);
        return result;
    }
}

export interface IJobTitle {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
    grade: Grade;
}

export enum KinshipLevel {
    _0 = 0,
    _1 = 1,
}

export class KinshipType implements IKinshipType {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IKinshipType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): KinshipType {
        data = typeof data === 'object' ? data : {};
        let result = new KinshipType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): KinshipType {
        const json = this.toJSON();
        let result = new KinshipType();
        result.init(json);
        return result;
    }
}

export interface IKinshipType {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class KinshipTypeDto implements IKinshipTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IKinshipTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): KinshipTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new KinshipTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): KinshipTypeDto {
        const json = this.toJSON();
        let result = new KinshipTypeDto();
        result.init(json);
        return result;
    }
}

export interface IKinshipTypeDto {
    id: string;
    name: string | undefined;
}

export class KinshipTypeDtoPagedResultDto implements IKinshipTypeDtoPagedResultDto {
    items: KinshipTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IKinshipTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(KinshipTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): KinshipTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new KinshipTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): KinshipTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new KinshipTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IKinshipTypeDtoPagedResultDto {
    items: KinshipTypeDto[] | undefined;
    totalCount: number;
}

export class Language implements ILanguage {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    languageNameId: string;
    languageName: LanguageName;
    writingId: string;
    writing: Level;
    readingId: string;
    reading: Level;
    speakingId: string;
    speaking: Level;
    listeningId: string;
    listening: Level;
    attachments: Attachment[] | undefined;

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.languageNameId = _data["languageNameId"];
            this.languageName = _data["languageName"] ? LanguageName.fromJS(_data["languageName"]) : <any>undefined;
            this.writingId = _data["writingId"];
            this.writing = _data["writing"] ? Level.fromJS(_data["writing"]) : <any>undefined;
            this.readingId = _data["readingId"];
            this.reading = _data["reading"] ? Level.fromJS(_data["reading"]) : <any>undefined;
            this.speakingId = _data["speakingId"];
            this.speaking = _data["speaking"] ? Level.fromJS(_data["speaking"]) : <any>undefined;
            this.listeningId = _data["listeningId"];
            this.listening = _data["listening"] ? Level.fromJS(_data["listening"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["languageNameId"] = this.languageNameId;
        data["languageName"] = this.languageName ? this.languageName.toJSON() : <any>undefined;
        data["writingId"] = this.writingId;
        data["writing"] = this.writing ? this.writing.toJSON() : <any>undefined;
        data["readingId"] = this.readingId;
        data["reading"] = this.reading ? this.reading.toJSON() : <any>undefined;
        data["speakingId"] = this.speakingId;
        data["speaking"] = this.speaking ? this.speaking.toJSON() : <any>undefined;
        data["listeningId"] = this.listeningId;
        data["listening"] = this.listening ? this.listening.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Language {
        const json = this.toJSON();
        let result = new Language();
        result.init(json);
        return result;
    }
}

export interface ILanguage {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    languageNameId: string;
    languageName: LanguageName;
    writingId: string;
    writing: Level;
    readingId: string;
    reading: Level;
    speakingId: string;
    speaking: Level;
    listeningId: string;
    listening: Level;
    attachments: Attachment[] | undefined;
}

export class LanguageName implements ILanguageName {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: ILanguageName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageName {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): LanguageName {
        const json = this.toJSON();
        let result = new LanguageName();
        result.init(json);
        return result;
    }
}

export interface ILanguageName {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class LanguageNameDto implements ILanguageNameDto {
    id: string;
    name: string | undefined;

    constructor(data?: ILanguageNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LanguageNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): LanguageNameDto {
        const json = this.toJSON();
        let result = new LanguageNameDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageNameDto {
    id: string;
    name: string | undefined;
}

export class LanguageNameDtoPagedResultDto implements ILanguageNameDtoPagedResultDto {
    items: LanguageNameDto[] | undefined;
    totalCount: number;

    constructor(data?: ILanguageNameDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LanguageNameDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LanguageNameDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageNameDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LanguageNameDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LanguageNameDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageNameDtoPagedResultDto {
    items: LanguageNameDto[] | undefined;
    totalCount: number;
}

export class LeaveRequest implements ILeaveRequest {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    leaveSettingId: string;
    leaveSetting: LeaveSetting;
    employeeId: string;
    employee: Employee;
    requestDate: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isHourly: boolean;
    startHour: moment.Moment | undefined;
    endHour: moment.Moment | undefined;
    leaveRequestStatus: LeaveRequestStatus;
    readonly leaveRequestBalance: number;
    description: string | undefined;

    constructor(data?: ILeaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.leaveSettingId = _data["leaveSettingId"];
            this.leaveSetting = _data["leaveSetting"] ? LeaveSetting.fromJS(_data["leaveSetting"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.requestDate = _data["requestDate"] ? moment(_data["requestDate"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.isHourly = _data["isHourly"];
            this.startHour = _data["startHour"] ? moment(_data["startHour"].toString()) : <any>undefined;
            this.endHour = _data["endHour"] ? moment(_data["endHour"].toString()) : <any>undefined;
            this.leaveRequestStatus = _data["leaveRequestStatus"];
            (<any>this).leaveRequestBalance = _data["leaveRequestBalance"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): LeaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["leaveSettingId"] = this.leaveSettingId;
        data["leaveSetting"] = this.leaveSetting ? this.leaveSetting.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isHourly"] = this.isHourly;
        data["startHour"] = this.startHour ? this.startHour.toISOString() : <any>undefined;
        data["endHour"] = this.endHour ? this.endHour.toISOString() : <any>undefined;
        data["leaveRequestStatus"] = this.leaveRequestStatus;
        data["leaveRequestBalance"] = this.leaveRequestBalance;
        data["description"] = this.description;
        return data;
    }

    clone(): LeaveRequest {
        const json = this.toJSON();
        let result = new LeaveRequest();
        result.init(json);
        return result;
    }
}

export interface ILeaveRequest {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    leaveSettingId: string;
    leaveSetting: LeaveSetting;
    employeeId: string;
    employee: Employee;
    requestDate: moment.Moment;
    startDate: moment.Moment;
    endDate: moment.Moment;
    isHourly: boolean;
    startHour: moment.Moment | undefined;
    endHour: moment.Moment | undefined;
    leaveRequestStatus: LeaveRequestStatus;
    leaveRequestBalance: number;
    description: string | undefined;
}

export enum LeaveRequestStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class LeaveSetting implements ILeaveSetting {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    workflowSetting: WorkflowSetting;
    description: string | undefined;

    constructor(data?: ILeaveSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.isPaidLeave = _data["isPaidLeave"];
            this.workflowSettingId = _data["workflowSettingId"];
            this.workflowSetting = _data["workflowSetting"] ? WorkflowSetting.fromJS(_data["workflowSetting"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): LeaveSetting {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["isPaidLeave"] = this.isPaidLeave;
        data["workflowSettingId"] = this.workflowSettingId;
        data["workflowSetting"] = this.workflowSetting ? this.workflowSetting.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): LeaveSetting {
        const json = this.toJSON();
        let result = new LeaveSetting();
        result.init(json);
        return result;
    }
}

export interface ILeaveSetting {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    workflowSetting: WorkflowSetting;
    description: string | undefined;
}

export class Level implements ILevel {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: ILevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Level {
        data = typeof data === 'object' ? data : {};
        let result = new Level();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Level {
        const json = this.toJSON();
        let result = new Level();
        result.init(json);
        return result;
    }
}

export interface ILevel {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class LevelDto implements ILevelDto {
    id: string;
    name: string | undefined;

    constructor(data?: ILevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new LevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): LevelDto {
        const json = this.toJSON();
        let result = new LevelDto();
        result.init(json);
        return result;
    }
}

export interface ILevelDto {
    id: string;
    name: string | undefined;
}

export class LevelDtoPagedResultDto implements ILevelDtoPagedResultDto {
    items: LevelDto[] | undefined;
    totalCount: number;

    constructor(data?: ILevelDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(LevelDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): LevelDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LevelDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): LevelDtoPagedResultDto {
        const json = this.toJSON();
        let result = new LevelDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ILevelDtoPagedResultDto {
    items: LevelDto[] | undefined;
    totalCount: number;
}

export enum MaritialStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class MilitaryService implements IMilitaryService {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IMilitaryService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.militaryStatus = _data["militaryStatus"];
            this.isPermanentExemption = _data["isPermanentExemption"];
            this.exemptionReason = _data["exemptionReason"];
            this.exemptionDate = _data["exemptionDate"] ? moment(_data["exemptionDate"].toString()) : <any>undefined;
            this.delayReason = _data["delayReason"];
            this.delayDate = _data["delayDate"] ? moment(_data["delayDate"].toString()) : <any>undefined;
            this.militaryServiceNo = _data["militaryServiceNo"];
            this.militaryServiceDocIssueDate = _data["militaryServiceDocIssueDate"] ? moment(_data["militaryServiceDocIssueDate"].toString()) : <any>undefined;
            this.granter = _data["granter"];
            this.years = _data["years"];
            this.months = _data["months"];
            this.days = _data["days"];
            this.serviceStartDate = _data["serviceStartDate"] ? moment(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? moment(_data["serviceEndDate"].toString()) : <any>undefined;
            this.holdDate = _data["holdDate"] ? moment(_data["holdDate"].toString()) : <any>undefined;
            this.reserveStartDate = _data["reserveStartDate"] ? moment(_data["reserveStartDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MilitaryService {
        data = typeof data === 'object' ? data : {};
        let result = new MilitaryService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["militaryStatus"] = this.militaryStatus;
        data["isPermanentExemption"] = this.isPermanentExemption;
        data["exemptionReason"] = this.exemptionReason;
        data["exemptionDate"] = this.exemptionDate ? this.exemptionDate.toISOString() : <any>undefined;
        data["delayReason"] = this.delayReason;
        data["delayDate"] = this.delayDate ? this.delayDate.toISOString() : <any>undefined;
        data["militaryServiceNo"] = this.militaryServiceNo;
        data["militaryServiceDocIssueDate"] = this.militaryServiceDocIssueDate ? this.militaryServiceDocIssueDate.toISOString() : <any>undefined;
        data["granter"] = this.granter;
        data["years"] = this.years;
        data["months"] = this.months;
        data["days"] = this.days;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toISOString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toISOString() : <any>undefined;
        data["holdDate"] = this.holdDate ? this.holdDate.toISOString() : <any>undefined;
        data["reserveStartDate"] = this.reserveStartDate ? this.reserveStartDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): MilitaryService {
        const json = this.toJSON();
        let result = new MilitaryService();
        result.init(json);
        return result;
    }
}

export interface IMilitaryService {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
    attachments: Attachment[] | undefined;
}

export enum MilitaryStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum MonthName {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
}

export class Nationality implements INationality {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: INationality) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Nationality {
        data = typeof data === 'object' ? data : {};
        let result = new Nationality();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Nationality {
        const json = this.toJSON();
        let result = new Nationality();
        result.init(json);
        return result;
    }
}

export interface INationality {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class NationalityDto implements INationalityDto {
    id: string;
    name: string | undefined;

    constructor(data?: INationalityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): NationalityDto {
        data = typeof data === 'object' ? data : {};
        let result = new NationalityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): NationalityDto {
        const json = this.toJSON();
        let result = new NationalityDto();
        result.init(json);
        return result;
    }
}

export interface INationalityDto {
    id: string;
    name: string | undefined;
}

export class NationalityDtoPagedResultDto implements INationalityDtoPagedResultDto {
    items: NationalityDto[] | undefined;
    totalCount: number;

    constructor(data?: INationalityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(NationalityDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NationalityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NationalityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NationalityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NationalityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INationalityDtoPagedResultDto {
    items: NationalityDto[] | undefined;
    totalCount: number;
}

export class Node implements INode {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    type: NodeType;
    parentId: string | undefined;
    parent: Node;
    code: string | undefined;
    isRoot: boolean;
    jobDescriptions: JobDescription[] | undefined;
    childrens: Node[] | undefined;

    constructor(data?: INode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.parent = _data["parent"] ? Node.fromJS(_data["parent"]) : <any>undefined;
            this.code = _data["code"];
            this.isRoot = _data["isRoot"];
            if (Array.isArray(_data["jobDescriptions"])) {
                this.jobDescriptions = [] as any;
                for (let item of _data["jobDescriptions"])
                    this.jobDescriptions.push(JobDescription.fromJS(item));
            }
            if (Array.isArray(_data["childrens"])) {
                this.childrens = [] as any;
                for (let item of _data["childrens"])
                    this.childrens.push(Node.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Node {
        data = typeof data === 'object' ? data : {};
        let result = new Node();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["isRoot"] = this.isRoot;
        if (Array.isArray(this.jobDescriptions)) {
            data["jobDescriptions"] = [];
            for (let item of this.jobDescriptions)
                data["jobDescriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.childrens)) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        return data;
    }

    clone(): Node {
        const json = this.toJSON();
        let result = new Node();
        result.init(json);
        return result;
    }
}

export interface INode {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    type: NodeType;
    parentId: string | undefined;
    parent: Node;
    code: string | undefined;
    isRoot: boolean;
    jobDescriptions: JobDescription[] | undefined;
    childrens: Node[] | undefined;
}

export enum NodeType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
}

export class NormalShift implements INormalShift {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    entryTime: moment.Moment;
    workshopId: string;
    workshop: Workshop;
    exitTime: moment.Moment;
    shiftRangeStartTime: moment.Moment;
    shiftRangeEndTime: moment.Moment;

    constructor(data?: INormalShift) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.entryTime = _data["entryTime"] ? moment(_data["entryTime"].toString()) : <any>undefined;
            this.workshopId = _data["workshopId"];
            this.workshop = _data["workshop"] ? Workshop.fromJS(_data["workshop"]) : <any>undefined;
            this.exitTime = _data["exitTime"] ? moment(_data["exitTime"].toString()) : <any>undefined;
            this.shiftRangeStartTime = _data["shiftRangeStartTime"] ? moment(_data["shiftRangeStartTime"].toString()) : <any>undefined;
            this.shiftRangeEndTime = _data["shiftRangeEndTime"] ? moment(_data["shiftRangeEndTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NormalShift {
        data = typeof data === 'object' ? data : {};
        let result = new NormalShift();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["entryTime"] = this.entryTime ? this.entryTime.toISOString() : <any>undefined;
        data["workshopId"] = this.workshopId;
        data["workshop"] = this.workshop ? this.workshop.toJSON() : <any>undefined;
        data["exitTime"] = this.exitTime ? this.exitTime.toISOString() : <any>undefined;
        data["shiftRangeStartTime"] = this.shiftRangeStartTime ? this.shiftRangeStartTime.toISOString() : <any>undefined;
        data["shiftRangeEndTime"] = this.shiftRangeEndTime ? this.shiftRangeEndTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): NormalShift {
        const json = this.toJSON();
        let result = new NormalShift();
        result.init(json);
        return result;
    }
}

export interface INormalShift {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    entryTime: moment.Moment;
    workshopId: string;
    workshop: Workshop;
    exitTime: moment.Moment;
    shiftRangeStartTime: moment.Moment;
    shiftRangeEndTime: moment.Moment;
}

export class OrganizationLevel implements IOrganizationLevel {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IOrganizationLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): OrganizationLevel {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): OrganizationLevel {
        const json = this.toJSON();
        let result = new OrganizationLevel();
        result.init(json);
        return result;
    }
}

export interface IOrganizationLevel {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class Passport implements IPassport {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    placeofIssuance: City;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    attachments: Attachment[] | undefined;

    constructor(data?: IPassport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.placeofIssuance = _data["placeofIssuance"] ? City.fromJS(_data["placeofIssuance"]) : <any>undefined;
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Passport {
        data = typeof data === 'object' ? data : {};
        let result = new Passport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Passport {
        const json = this.toJSON();
        let result = new Passport();
        result.init(json);
        return result;
    }
}

export interface IPassport {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    placeofIssuance: City;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    attachments: Attachment[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class Position implements IPosition {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobDescriptionId: string;
    jobDescription: JobDescription;
    positionWorkTypeId: string;
    positionWorkType: PositionWorkType;
    workingHours: number;
    per: HoursPer;
    hasManager: boolean;
    managerId: string | undefined;
    manager: Position;
    employeeId: string | undefined;
    employee: Employee;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.jobDescription = _data["jobDescription"] ? JobDescription.fromJS(_data["jobDescription"]) : <any>undefined;
            this.positionWorkTypeId = _data["positionWorkTypeId"];
            this.positionWorkType = _data["positionWorkType"] ? PositionWorkType.fromJS(_data["positionWorkType"]) : <any>undefined;
            this.workingHours = _data["workingHours"];
            this.per = _data["per"];
            this.hasManager = _data["hasManager"];
            this.managerId = _data["managerId"];
            this.manager = _data["manager"] ? Position.fromJS(_data["manager"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["jobDescription"] = this.jobDescription ? this.jobDescription.toJSON() : <any>undefined;
        data["positionWorkTypeId"] = this.positionWorkTypeId;
        data["positionWorkType"] = this.positionWorkType ? this.positionWorkType.toJSON() : <any>undefined;
        data["workingHours"] = this.workingHours;
        data["per"] = this.per;
        data["hasManager"] = this.hasManager;
        data["managerId"] = this.managerId;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data;
    }

    clone(): Position {
        const json = this.toJSON();
        let result = new Position();
        result.init(json);
        return result;
    }
}

export interface IPosition {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobDescriptionId: string;
    jobDescription: JobDescription;
    positionWorkTypeId: string;
    positionWorkType: PositionWorkType;
    workingHours: number;
    per: HoursPer;
    hasManager: boolean;
    managerId: string | undefined;
    manager: Position;
    employeeId: string | undefined;
    employee: Employee;
}

export class PositionWorkType implements IPositionWorkType {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IPositionWorkType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PositionWorkType {
        data = typeof data === 'object' ? data : {};
        let result = new PositionWorkType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): PositionWorkType {
        const json = this.toJSON();
        let result = new PositionWorkType();
        result.init(json);
        return result;
    }
}

export interface IPositionWorkType {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class Promotion implements IPromotion {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    positionId: string;
    position: Position;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    promotionDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? JobTitle.fromJS(_data["jobTitle"]) : <any>undefined;
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? Position.fromJS(_data["position"]) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? EmployeeCard.fromJS(_data["employeeCard"]) : <any>undefined;
            this.promotionDate = _data["promotionDate"] ? moment(_data["promotionDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Promotion {
        data = typeof data === 'object' ? data : {};
        let result = new Promotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["promotionDate"] = this.promotionDate ? this.promotionDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): Promotion {
        const json = this.toJSON();
        let result = new Promotion();
        result.init(json);
        return result;
    }
}

export interface IPromotion {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    jobTitleId: string;
    jobTitle: JobTitle;
    positionId: string;
    position: Position;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    promotionDate: moment.Moment;
    description: string | undefined;
}

export class Rank implements IRank {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IRank) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Rank {
        data = typeof data === 'object' ? data : {};
        let result = new Rank();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Rank {
        const json = this.toJSON();
        let result = new Rank();
        result.init(json);
        return result;
    }
}

export interface IRank {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class RankDto implements IRankDto {
    id: string;
    name: string | undefined;

    constructor(data?: IRankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RankDto {
        data = typeof data === 'object' ? data : {};
        let result = new RankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): RankDto {
        const json = this.toJSON();
        let result = new RankDto();
        result.init(json);
        return result;
    }
}

export interface IRankDto {
    id: string;
    name: string | undefined;
}

export class RankDtoPagedResultDto implements IRankDtoPagedResultDto {
    items: RankDto[] | undefined;
    totalCount: number;

    constructor(data?: IRankDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RankDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RankDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RankDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RankDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RankDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRankDtoPagedResultDto {
    items: RankDto[] | undefined;
    totalCount: number;
}

export class ReadAssignmentDto implements IReadAssignmentDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    positionID: string;
    position: ReadPositionDto;
    employeeCardId: string;
    employeeCard: ReadEmployeeCardDto;
    assigningDate: string | undefined;
    description: string | undefined;

    constructor(data?: IReadAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? ReadJobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.positionID = _data["positionID"];
            this.position = _data["position"] ? ReadPositionDto.fromJS(_data["position"]) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? ReadEmployeeCardDto.fromJS(_data["employeeCard"]) : <any>undefined;
            this.assigningDate = _data["assigningDate"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["positionID"] = this.positionID;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["assigningDate"] = this.assigningDate;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadAssignmentDto {
        const json = this.toJSON();
        let result = new ReadAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IReadAssignmentDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    positionID: string;
    position: ReadPositionDto;
    employeeCardId: string;
    employeeCard: ReadEmployeeCardDto;
    assigningDate: string | undefined;
    description: string | undefined;
}

export class ReadAssignmentDtoPagedResultDto implements IReadAssignmentDtoPagedResultDto {
    items: ReadAssignmentDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadAssignmentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadAssignmentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadAssignmentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAssignmentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadAssignmentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadAssignmentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadAssignmentDtoPagedResultDto {
    items: ReadAssignmentDto[] | undefined;
    totalCount: number;
}

export class ReadAttachmentDto implements IReadAttachmentDto {
    id: string;
    title: string | undefined;
    description: string | undefined;

    constructor(data?: IReadAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadAttachmentDto {
        const json = this.toJSON();
        let result = new ReadAttachmentDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttachmentDto {
    id: string;
    title: string | undefined;
    description: string | undefined;
}

export class ReadAttendanceFormDto implements IReadAttendanceFormDto {
    id: string;
    name: string | undefined;
    workshops: ReadWorkshopDto[] | undefined;

    constructor(data?: IReadAttendanceFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["workshops"])) {
                this.workshops = [] as any;
                for (let item of _data["workshops"])
                    this.workshops.push(ReadWorkshopDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadAttendanceFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.workshops)) {
            data["workshops"] = [];
            for (let item of this.workshops)
                data["workshops"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadAttendanceFormDto {
        const json = this.toJSON();
        let result = new ReadAttendanceFormDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceFormDto {
    id: string;
    name: string | undefined;
    workshops: ReadWorkshopDto[] | undefined;
}

export class ReadAttendanceFormDtoPagedResultDto implements IReadAttendanceFormDtoPagedResultDto {
    items: ReadAttendanceFormDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadAttendanceFormDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadAttendanceFormDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadAttendanceFormDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceFormDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadAttendanceFormDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadAttendanceFormDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceFormDtoPagedResultDto {
    items: ReadAttendanceFormDto[] | undefined;
    totalCount: number;
}

export class ReadAttendanceMonthlyCardDto implements IReadAttendanceMonthlyCardDto {
    id: string;
    employeeCard: ReadEmployeeCardDto;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;

    constructor(data?: IReadAttendanceMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCard = _data["employeeCard"] ? ReadEmployeeCardDto.fromJS(_data["employeeCard"]) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.totalRequiredWorkHours = _data["totalRequiredWorkHours"];
            this.actualTotalWorkHours = _data["actualTotalWorkHours"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): ReadAttendanceMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["totalRequiredWorkHours"] = this.totalRequiredWorkHours;
        data["actualTotalWorkHours"] = this.actualTotalWorkHours;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): ReadAttendanceMonthlyCardDto {
        const json = this.toJSON();
        let result = new ReadAttendanceMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceMonthlyCardDto {
    id: string;
    employeeCard: ReadEmployeeCardDto;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;
}

export class ReadAttendanceMonthlyCardDtoPagedResultDto implements IReadAttendanceMonthlyCardDtoPagedResultDto {
    items: ReadAttendanceMonthlyCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadAttendanceMonthlyCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadAttendanceMonthlyCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadAttendanceMonthlyCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceMonthlyCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadAttendanceMonthlyCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadAttendanceMonthlyCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceMonthlyCardDtoPagedResultDto {
    items: ReadAttendanceMonthlyCardDto[] | undefined;
    totalCount: number;
}

export class ReadAttendanceRecordDto implements IReadAttendanceRecordDto {
    id: string;
    year: number;
    month: MonthName;
    name: string | undefined;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    note: string | undefined;
    attendanceMonthlyCards: ReadAttendanceMonthlyCardDto[] | undefined;
    isCalculated: boolean;

    constructor(data?: IReadAttendanceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.name = _data["name"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.note = _data["note"];
            if (Array.isArray(_data["attendanceMonthlyCards"])) {
                this.attendanceMonthlyCards = [] as any;
                for (let item of _data["attendanceMonthlyCards"])
                    this.attendanceMonthlyCards.push(ReadAttendanceMonthlyCardDto.fromJS(item));
            }
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): ReadAttendanceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["month"] = this.month;
        data["name"] = this.name;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["note"] = this.note;
        if (Array.isArray(this.attendanceMonthlyCards)) {
            data["attendanceMonthlyCards"] = [];
            for (let item of this.attendanceMonthlyCards)
                data["attendanceMonthlyCards"].push(item.toJSON());
        }
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): ReadAttendanceRecordDto {
        const json = this.toJSON();
        let result = new ReadAttendanceRecordDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceRecordDto {
    id: string;
    year: number;
    month: MonthName;
    name: string | undefined;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    note: string | undefined;
    attendanceMonthlyCards: ReadAttendanceMonthlyCardDto[] | undefined;
    isCalculated: boolean;
}

export class ReadAttendanceRecordDtoPagedResultDto implements IReadAttendanceRecordDtoPagedResultDto {
    items: ReadAttendanceRecordDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadAttendanceRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadAttendanceRecordDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadAttendanceRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadAttendanceRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadAttendanceRecordDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadAttendanceRecordDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadAttendanceRecordDtoPagedResultDto {
    items: ReadAttendanceRecordDto[] | undefined;
    totalCount: number;
}

export class ReadBankDto implements IReadBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    nationality: NationalityDto;
    phoneNumber: string | undefined;

    constructor(data?: IReadBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): ReadBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): ReadBankDto {
        const json = this.toJSON();
        let result = new ReadBankDto();
        result.init(json);
        return result;
    }
}

export interface IReadBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    nationality: NationalityDto;
    phoneNumber: string | undefined;
}

export class ReadBankDtoPagedResultDto implements IReadBankDtoPagedResultDto {
    items: ReadBankDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadBankDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadBankDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadBankDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBankDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadBankDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadBankDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadBankDtoPagedResultDto {
    items: ReadBankDto[] | undefined;
    totalCount: number;
}

export class ReadBankInformationDto implements IReadBankInformationDto {
    id: string;
    bankId: string;
    bank: ReadBankDto;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;

    constructor(data?: IReadBankInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankId = _data["bankId"];
            this.bank = _data["bank"] ? ReadBankDto.fromJS(_data["bank"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReadBankInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBankInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankId"] = this.bankId;
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): ReadBankInformationDto {
        const json = this.toJSON();
        let result = new ReadBankInformationDto();
        result.init(json);
        return result;
    }
}

export interface IReadBankInformationDto {
    id: string;
    bankId: string;
    bank: ReadBankDto;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
}

export class ReadBankInformationDtoPagedResultDto implements IReadBankInformationDtoPagedResultDto {
    items: ReadBankInformationDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadBankInformationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadBankInformationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadBankInformationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBankInformationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadBankInformationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadBankInformationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadBankInformationDtoPagedResultDto {
    items: ReadBankInformationDto[] | undefined;
    totalCount: number;
}

export class ReadBenefitCardDto implements IReadBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IReadBenefitCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): ReadBenefitCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBenefitCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): ReadBenefitCardDto {
        const json = this.toJSON();
        let result = new ReadBenefitCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class ReadBenefitCardDtoPagedResultDto implements IReadBenefitCardDtoPagedResultDto {
    items: ReadBenefitCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadBenefitCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadBenefitCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadBenefitCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadBenefitCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadBenefitCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadBenefitCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadBenefitCardDtoPagedResultDto {
    items: ReadBenefitCardDto[] | undefined;
    totalCount: number;
}

export class ReadCertificateDto implements IReadCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    placeofIssuance: CityDto;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadCertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.placeofIssuance = _data["placeofIssuance"] ? CityDto.fromJS(_data["placeofIssuance"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadCertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadCertificateDto {
        const json = this.toJSON();
        let result = new ReadCertificateDto();
        result.init(json);
        return result;
    }
}

export interface IReadCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    placeofIssuance: CityDto;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadCertificateDtoPagedResultDto implements IReadCertificateDtoPagedResultDto {
    items: ReadCertificateDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadCertificateDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadCertificateDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadCertificateDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCertificateDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadCertificateDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadCertificateDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadCertificateDtoPagedResultDto {
    items: ReadCertificateDto[] | undefined;
    totalCount: number;
}

export class ReadChangeableHolidayDto implements IReadChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;

    constructor(data?: IReadChangeableHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
        }
    }

    static fromJS(data: any): ReadChangeableHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadChangeableHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        return data;
    }

    clone(): ReadChangeableHolidayDto {
        const json = this.toJSON();
        let result = new ReadChangeableHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IReadChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
}

export class ReadChangeableHolidayDtoPagedResultDto implements IReadChangeableHolidayDtoPagedResultDto {
    items: ReadChangeableHolidayDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadChangeableHolidayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadChangeableHolidayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadChangeableHolidayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadChangeableHolidayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadChangeableHolidayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadChangeableHolidayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadChangeableHolidayDtoPagedResultDto {
    items: ReadChangeableHolidayDto[] | undefined;
    totalCount: number;
}

export class ReadChildrenDto implements IReadChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    spouse: ReadSpouseDto;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadChildrenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.spouseId = _data["spouseId"];
            this.spouse = _data["spouse"] ? ReadSpouseDto.fromJS(_data["spouse"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.orderInFamily = _data["orderInFamily"];
            this.gender = _data["gender"];
            this.maritialStatus = _data["maritialStatus"];
            this.isEmployed = _data["isEmployed"];
            this.isStudying = _data["isStudying"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.disabilityExist = _data["disabilityExist"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? CityDto.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.residencyNo = _data["residencyNo"];
            this.residencExpireDate = _data["residencExpireDate"] ? moment(_data["residencExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadChildrenDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadChildrenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["spouseId"] = this.spouseId;
        data["spouse"] = this.spouse ? this.spouse.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["orderInFamily"] = this.orderInFamily;
        data["gender"] = this.gender;
        data["maritialStatus"] = this.maritialStatus;
        data["isEmployed"] = this.isEmployed;
        data["isStudying"] = this.isStudying;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["disabilityExist"] = this.disabilityExist;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residencyNo"] = this.residencyNo;
        data["residencExpireDate"] = this.residencExpireDate ? this.residencExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadChildrenDto {
        const json = this.toJSON();
        let result = new ReadChildrenDto();
        result.init(json);
        return result;
    }
}

export interface IReadChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    spouse: ReadSpouseDto;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadChildrenDtoPagedResultDto implements IReadChildrenDtoPagedResultDto {
    items: ReadChildrenDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadChildrenDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadChildrenDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadChildrenDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadChildrenDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadChildrenDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadChildrenDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadChildrenDtoPagedResultDto {
    items: ReadChildrenDto[] | undefined;
    totalCount: number;
}

export class ReadCompanyHolidayDto implements IReadCompanyHolidayDto {
    id: string;
    dayOfWeek: number;

    constructor(data?: IReadCompanyHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dayOfWeek = _data["dayOfWeek"];
        }
    }

    static fromJS(data: any): ReadCompanyHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCompanyHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dayOfWeek"] = this.dayOfWeek;
        return data;
    }

    clone(): ReadCompanyHolidayDto {
        const json = this.toJSON();
        let result = new ReadCompanyHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IReadCompanyHolidayDto {
    id: string;
    dayOfWeek: number;
}

export class ReadCompanyHolidayDtoPagedResultDto implements IReadCompanyHolidayDtoPagedResultDto {
    items: ReadCompanyHolidayDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadCompanyHolidayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadCompanyHolidayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadCompanyHolidayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCompanyHolidayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadCompanyHolidayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadCompanyHolidayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadCompanyHolidayDtoPagedResultDto {
    items: ReadCompanyHolidayDto[] | undefined;
    totalCount: number;
}

export class ReadConvictionDto implements IReadConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadConvictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.isConvicted = _data["isConvicted"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadConvictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadConvictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["isConvicted"] = this.isConvicted;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadConvictionDto {
        const json = this.toJSON();
        let result = new ReadConvictionDto();
        result.init(json);
        return result;
    }
}

export interface IReadConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadConvictionDtoPagedResultDto implements IReadConvictionDtoPagedResultDto {
    items: ReadConvictionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadConvictionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadConvictionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadConvictionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadConvictionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadConvictionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadConvictionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadConvictionDtoPagedResultDto {
    items: ReadConvictionDto[] | undefined;
    totalCount: number;
}

export class ReadCustodieDto implements IReadCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: IReadCustodieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ReadCustodieDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCustodieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): ReadCustodieDto {
        const json = this.toJSON();
        let result = new ReadCustodieDto();
        result.init(json);
        return result;
    }
}

export interface IReadCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class ReadCustodieDtoPagedResultDto implements IReadCustodieDtoPagedResultDto {
    items: ReadCustodieDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadCustodieDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadCustodieDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadCustodieDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadCustodieDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadCustodieDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadCustodieDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadCustodieDtoPagedResultDto {
    items: ReadCustodieDto[] | undefined;
    totalCount: number;
}

export class ReadDeductionCardDto implements IReadDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IReadDeductionCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): ReadDeductionCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDeductionCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): ReadDeductionCardDto {
        const json = this.toJSON();
        let result = new ReadDeductionCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class ReadDeductionCardDtoPagedResultDto implements IReadDeductionCardDtoPagedResultDto {
    items: ReadDeductionCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadDeductionCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadDeductionCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadDeductionCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDeductionCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadDeductionCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadDeductionCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadDeductionCardDtoPagedResultDto {
    items: ReadDeductionCardDto[] | undefined;
    totalCount: number;
}

export class ReadDependentDto implements IReadDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    kinshipType: KinshipTypeDto;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.kinshipLevel = _data["kinshipLevel"];
            this.kinshipTypeId = _data["kinshipTypeId"];
            this.kinshipType = _data["kinshipType"] ? KinshipTypeDto.fromJS(_data["kinshipType"]) : <any>undefined;
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? CityDto.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.contactNumber = _data["contactNumber"];
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["kinshipLevel"] = this.kinshipLevel;
        data["kinshipTypeId"] = this.kinshipTypeId;
        data["kinshipType"] = this.kinshipType ? this.kinshipType.toJSON() : <any>undefined;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["contactNumber"] = this.contactNumber;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadDependentDto {
        const json = this.toJSON();
        let result = new ReadDependentDto();
        result.init(json);
        return result;
    }
}

export interface IReadDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    kinshipType: KinshipTypeDto;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadDependentDtoPagedResultDto implements IReadDependentDtoPagedResultDto {
    items: ReadDependentDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadDependentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadDependentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadDependentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDependentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadDependentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadDependentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadDependentDtoPagedResultDto {
    items: ReadDependentDto[] | undefined;
    totalCount: number;
}

export class ReadDriverLicenseDto implements IReadDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    driverLicenseType: DriverLicenseTypeDto;
    placeofIssuanceId: string;
    placeofIssuance: CityDto;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadDriverLicenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.legalCondition = _data["legalCondition"];
            this.driverLicenseTypeId = _data["driverLicenseTypeId"];
            this.driverLicenseType = _data["driverLicenseType"] ? DriverLicenseTypeDto.fromJS(_data["driverLicenseType"]) : <any>undefined;
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.placeofIssuance = _data["placeofIssuance"] ? CityDto.fromJS(_data["placeofIssuance"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadDriverLicenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDriverLicenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["legalCondition"] = this.legalCondition;
        data["driverLicenseTypeId"] = this.driverLicenseTypeId;
        data["driverLicenseType"] = this.driverLicenseType ? this.driverLicenseType.toJSON() : <any>undefined;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadDriverLicenseDto {
        const json = this.toJSON();
        let result = new ReadDriverLicenseDto();
        result.init(json);
        return result;
    }
}

export interface IReadDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    driverLicenseType: DriverLicenseTypeDto;
    placeofIssuanceId: string;
    placeofIssuance: CityDto;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadDriverLicenseDtoPagedResultDto implements IReadDriverLicenseDtoPagedResultDto {
    items: ReadDriverLicenseDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadDriverLicenseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadDriverLicenseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadDriverLicenseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadDriverLicenseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadDriverLicenseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadDriverLicenseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadDriverLicenseDtoPagedResultDto {
    items: ReadDriverLicenseDto[] | undefined;
    totalCount: number;
}

export class ReadEducationDto implements IReadEducationDto {
    id: string;
    typeId: string;
    type: EducationTypeDto;
    majorId: string;
    major: EducationMajorDto;
    universityId: string;
    university: UniversityDto;
    rankId: string;
    rank: RankDto;
    scoreTypeId: string;
    scoreType: ScoreTypeDto;
    scoreId: string;
    score: ScoreDto;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    country: CountryDto;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadEducationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? EducationTypeDto.fromJS(_data["type"]) : <any>undefined;
            this.majorId = _data["majorId"];
            this.major = _data["major"] ? EducationMajorDto.fromJS(_data["major"]) : <any>undefined;
            this.universityId = _data["universityId"];
            this.university = _data["university"] ? UniversityDto.fromJS(_data["university"]) : <any>undefined;
            this.rankId = _data["rankId"];
            this.rank = _data["rank"] ? RankDto.fromJS(_data["rank"]) : <any>undefined;
            this.scoreTypeId = _data["scoreTypeId"];
            this.scoreType = _data["scoreType"] ? ScoreTypeDto.fromJS(_data["scoreType"]) : <any>undefined;
            this.scoreId = _data["scoreId"];
            this.score = _data["score"] ? ScoreDto.fromJS(_data["score"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.amendmentDocumentNo = _data["amendmentDocumentNo"];
            this.amendmentDocumentDate = _data["amendmentDocumentDate"] ? moment(_data["amendmentDocumentDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadEducationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEducationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["majorId"] = this.majorId;
        data["major"] = this.major ? this.major.toJSON() : <any>undefined;
        data["universityId"] = this.universityId;
        data["university"] = this.university ? this.university.toJSON() : <any>undefined;
        data["rankId"] = this.rankId;
        data["rank"] = this.rank ? this.rank.toJSON() : <any>undefined;
        data["scoreTypeId"] = this.scoreTypeId;
        data["scoreType"] = this.scoreType ? this.scoreType.toJSON() : <any>undefined;
        data["scoreId"] = this.scoreId;
        data["score"] = this.score ? this.score.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["amendmentDocumentNo"] = this.amendmentDocumentNo;
        data["amendmentDocumentDate"] = this.amendmentDocumentDate ? this.amendmentDocumentDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadEducationDto {
        const json = this.toJSON();
        let result = new ReadEducationDto();
        result.init(json);
        return result;
    }
}

export interface IReadEducationDto {
    id: string;
    typeId: string;
    type: EducationTypeDto;
    majorId: string;
    major: EducationMajorDto;
    universityId: string;
    university: UniversityDto;
    rankId: string;
    rank: RankDto;
    scoreTypeId: string;
    scoreType: ScoreTypeDto;
    scoreId: string;
    score: ScoreDto;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    country: CountryDto;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadEducationDtoPagedResultDto implements IReadEducationDtoPagedResultDto {
    items: ReadEducationDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadEducationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadEducationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadEducationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEducationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadEducationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadEducationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadEducationDtoPagedResultDto {
    items: ReadEducationDto[] | undefined;
    totalCount: number;
}

export class ReadEducationGradeDto implements IReadEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;

    constructor(data?: IReadEducationGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadEducationGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEducationGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadEducationGradeDto {
        const json = this.toJSON();
        let result = new ReadEducationGradeDto();
        result.init(json);
        return result;
    }
}

export interface IReadEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;
}

export class ReadEducationGradeDtoPagedResultDto implements IReadEducationGradeDtoPagedResultDto {
    items: ReadEducationGradeDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadEducationGradeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadEducationGradeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadEducationGradeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEducationGradeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadEducationGradeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadEducationGradeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadEducationGradeDtoPagedResultDto {
    items: ReadEducationGradeDto[] | undefined;
    totalCount: number;
}

export class ReadEmployeeCardDto implements IReadEmployeeCardDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    readonly fatherName: string | undefined;
    jobDescriptionId: string | undefined;
    jobDescription: ReadJobDescriptionDto;
    positionId: string | undefined;
    position: ReadPositionDto;
    jobTitleId: string | undefined;
    jobTitle: ReadJobTitleDto;
    gradeId: string | undefined;
    grade: ReadGradeDto;
    attendanceFormId: string | undefined;
    attendanceForm: ReadAttendanceFormDto;
    startWorkingDate: string | undefined;
    endWorkingDate: string | undefined;
    probationPeriodDate: string | undefined;
    contractType: number;

    constructor(data?: IReadEmployeeCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            (<any>this).fatherName = _data["fatherName"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.jobDescription = _data["jobDescription"] ? ReadJobDescriptionDto.fromJS(_data["jobDescription"]) : <any>undefined;
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? ReadPositionDto.fromJS(_data["position"]) : <any>undefined;
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? ReadJobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"] ? ReadGradeDto.fromJS(_data["grade"]) : <any>undefined;
            this.attendanceFormId = _data["attendanceFormId"];
            this.attendanceForm = _data["attendanceForm"] ? ReadAttendanceFormDto.fromJS(_data["attendanceForm"]) : <any>undefined;
            this.startWorkingDate = _data["startWorkingDate"];
            this.endWorkingDate = _data["endWorkingDate"];
            this.probationPeriodDate = _data["probationPeriodDate"];
            this.contractType = _data["contractType"];
        }
    }

    static fromJS(data: any): ReadEmployeeCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEmployeeCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["fatherName"] = this.fatherName;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["jobDescription"] = this.jobDescription ? this.jobDescription.toJSON() : <any>undefined;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        data["attendanceFormId"] = this.attendanceFormId;
        data["attendanceForm"] = this.attendanceForm ? this.attendanceForm.toJSON() : <any>undefined;
        data["startWorkingDate"] = this.startWorkingDate;
        data["endWorkingDate"] = this.endWorkingDate;
        data["probationPeriodDate"] = this.probationPeriodDate;
        data["contractType"] = this.contractType;
        return data;
    }

    clone(): ReadEmployeeCardDto {
        const json = this.toJSON();
        let result = new ReadEmployeeCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadEmployeeCardDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    fatherName: string | undefined;
    jobDescriptionId: string | undefined;
    jobDescription: ReadJobDescriptionDto;
    positionId: string | undefined;
    position: ReadPositionDto;
    jobTitleId: string | undefined;
    jobTitle: ReadJobTitleDto;
    gradeId: string | undefined;
    grade: ReadGradeDto;
    attendanceFormId: string | undefined;
    attendanceForm: ReadAttendanceFormDto;
    startWorkingDate: string | undefined;
    endWorkingDate: string | undefined;
    probationPeriodDate: string | undefined;
    contractType: number;
}

export class ReadEmployeeCardDtoPagedResultDto implements IReadEmployeeCardDtoPagedResultDto {
    items: ReadEmployeeCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadEmployeeCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadEmployeeCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadEmployeeCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEmployeeCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadEmployeeCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadEmployeeCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadEmployeeCardDtoPagedResultDto {
    items: ReadEmployeeCardDto[] | undefined;
    totalCount: number;
}

export class ReadEmployeeDto implements IReadEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    readonly fullName: string | undefined;
    readonly tripleName: string | undefined;
    placeofBirthId: string;
    placeofBirth: CityDto;
    dateofBirth: moment.Moment;
    readonly age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    countryofBirth: CountryDto;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    religion: ReligionDto;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    readonly fullNameAr: string | undefined;
    readonly tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    nationality: NationalityDto;
    secondaryNationalityId: string;
    secondaryNationality: NationalityDto;
    maritialStatus: number;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
    spouse: ReadSpouseDto[] | undefined;
    children: ReadChildrenDto[] | undefined;
    dependents: ReadDependentDto[] | undefined;
    educations: ReadEducationDto[] | undefined;
    trainings: ReadTrainingDto[] | undefined;
    experiences: ReadExperienceDto[] | undefined;
    skills: ReadSkillDto[] | undefined;
    languages: ReadLanguageDto[] | undefined;
    certificates: ReadCertificateDto[] | undefined;
    militaryService: ReadMilitaryServiceDto[] | undefined;
    passports: ReadPassportDto[] | undefined;
    driverLicense: ReadDriverLicenseDto[] | undefined;
    convictions: ReadConvictionDto[] | undefined;
    residences: ReadResidencyDto[] | undefined;
    positions: ReadPositionDto[] | undefined;
    bloodType: number;
    userId: number;
    user: UserDto;

    constructor(data?: IReadEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            (<any>this).fullName = _data["fullName"];
            (<any>this).tripleName = _data["tripleName"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? CityDto.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            (<any>this).age = _data["age"];
            this.idNumber = _data["idNumber"];
            this.countryofBirthId = _data["countryofBirthId"];
            this.countryofBirth = _data["countryofBirth"] ? CountryDto.fromJS(_data["countryofBirth"]) : <any>undefined;
            this.personalRecordSource = _data["personalRecordSource"];
            this.civilRecordPlaceAndNumber = _data["civilRecordPlaceAndNumber"];
            this.gender = _data["gender"];
            this.religionId = _data["religionId"];
            this.religion = _data["religion"] ? ReligionDto.fromJS(_data["religion"]) : <any>undefined;
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherNameAr = _data["fatherNameAr"];
            this.motherNameAr = _data["motherNameAr"];
            (<any>this).fullNameAr = _data["fullNameAr"];
            (<any>this).tripleNameAr = _data["tripleNameAr"];
            this.placeofBirthAr = _data["placeofBirthAr"];
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.secondaryNationalityId = _data["secondaryNationalityId"];
            this.secondaryNationality = _data["secondaryNationality"] ? NationalityDto.fromJS(_data["secondaryNationality"]) : <any>undefined;
            this.maritialStatus = _data["maritialStatus"];
            this.photoPath = _data["photoPath"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.webSite = _data["webSite"];
            this.facebook = _data["facebook"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
            if (Array.isArray(_data["spouse"])) {
                this.spouse = [] as any;
                for (let item of _data["spouse"])
                    this.spouse.push(ReadSpouseDto.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children.push(ReadChildrenDto.fromJS(item));
            }
            if (Array.isArray(_data["dependents"])) {
                this.dependents = [] as any;
                for (let item of _data["dependents"])
                    this.dependents.push(ReadDependentDto.fromJS(item));
            }
            if (Array.isArray(_data["educations"])) {
                this.educations = [] as any;
                for (let item of _data["educations"])
                    this.educations.push(ReadEducationDto.fromJS(item));
            }
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings.push(ReadTrainingDto.fromJS(item));
            }
            if (Array.isArray(_data["experiences"])) {
                this.experiences = [] as any;
                for (let item of _data["experiences"])
                    this.experiences.push(ReadExperienceDto.fromJS(item));
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills.push(ReadSkillDto.fromJS(item));
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages.push(ReadLanguageDto.fromJS(item));
            }
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates.push(ReadCertificateDto.fromJS(item));
            }
            if (Array.isArray(_data["militaryService"])) {
                this.militaryService = [] as any;
                for (let item of _data["militaryService"])
                    this.militaryService.push(ReadMilitaryServiceDto.fromJS(item));
            }
            if (Array.isArray(_data["passports"])) {
                this.passports = [] as any;
                for (let item of _data["passports"])
                    this.passports.push(ReadPassportDto.fromJS(item));
            }
            if (Array.isArray(_data["driverLicense"])) {
                this.driverLicense = [] as any;
                for (let item of _data["driverLicense"])
                    this.driverLicense.push(ReadDriverLicenseDto.fromJS(item));
            }
            if (Array.isArray(_data["convictions"])) {
                this.convictions = [] as any;
                for (let item of _data["convictions"])
                    this.convictions.push(ReadConvictionDto.fromJS(item));
            }
            if (Array.isArray(_data["residences"])) {
                this.residences = [] as any;
                for (let item of _data["residences"])
                    this.residences.push(ReadResidencyDto.fromJS(item));
            }
            if (Array.isArray(_data["positions"])) {
                this.positions = [] as any;
                for (let item of _data["positions"])
                    this.positions.push(ReadPositionDto.fromJS(item));
            }
            this.bloodType = _data["bloodType"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReadEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["fullName"] = this.fullName;
        data["tripleName"] = this.tripleName;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["idNumber"] = this.idNumber;
        data["countryofBirthId"] = this.countryofBirthId;
        data["countryofBirth"] = this.countryofBirth ? this.countryofBirth.toJSON() : <any>undefined;
        data["personalRecordSource"] = this.personalRecordSource;
        data["civilRecordPlaceAndNumber"] = this.civilRecordPlaceAndNumber;
        data["gender"] = this.gender;
        data["religionId"] = this.religionId;
        data["religion"] = this.religion ? this.religion.toJSON() : <any>undefined;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherNameAr"] = this.fatherNameAr;
        data["motherNameAr"] = this.motherNameAr;
        data["fullNameAr"] = this.fullNameAr;
        data["tripleNameAr"] = this.tripleNameAr;
        data["placeofBirthAr"] = this.placeofBirthAr;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["secondaryNationalityId"] = this.secondaryNationalityId;
        data["secondaryNationality"] = this.secondaryNationality ? this.secondaryNationality.toJSON() : <any>undefined;
        data["maritialStatus"] = this.maritialStatus;
        data["photoPath"] = this.photoPath;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["webSite"] = this.webSite;
        data["facebook"] = this.facebook;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.spouse)) {
            data["spouse"] = [];
            for (let item of this.spouse)
                data["spouse"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        if (Array.isArray(this.dependents)) {
            data["dependents"] = [];
            for (let item of this.dependents)
                data["dependents"].push(item.toJSON());
        }
        if (Array.isArray(this.educations)) {
            data["educations"] = [];
            for (let item of this.educations)
                data["educations"].push(item.toJSON());
        }
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        if (Array.isArray(this.experiences)) {
            data["experiences"] = [];
            for (let item of this.experiences)
                data["experiences"].push(item.toJSON());
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item.toJSON());
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (Array.isArray(this.militaryService)) {
            data["militaryService"] = [];
            for (let item of this.militaryService)
                data["militaryService"].push(item.toJSON());
        }
        if (Array.isArray(this.passports)) {
            data["passports"] = [];
            for (let item of this.passports)
                data["passports"].push(item.toJSON());
        }
        if (Array.isArray(this.driverLicense)) {
            data["driverLicense"] = [];
            for (let item of this.driverLicense)
                data["driverLicense"].push(item.toJSON());
        }
        if (Array.isArray(this.convictions)) {
            data["convictions"] = [];
            for (let item of this.convictions)
                data["convictions"].push(item.toJSON());
        }
        if (Array.isArray(this.residences)) {
            data["residences"] = [];
            for (let item of this.residences)
                data["residences"].push(item.toJSON());
        }
        if (Array.isArray(this.positions)) {
            data["positions"] = [];
            for (let item of this.positions)
                data["positions"].push(item.toJSON());
        }
        data["bloodType"] = this.bloodType;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReadEmployeeDto {
        const json = this.toJSON();
        let result = new ReadEmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IReadEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    fullName: string | undefined;
    tripleName: string | undefined;
    placeofBirthId: string;
    placeofBirth: CityDto;
    dateofBirth: moment.Moment;
    age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    countryofBirth: CountryDto;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    religion: ReligionDto;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    fullNameAr: string | undefined;
    tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    nationality: NationalityDto;
    secondaryNationalityId: string;
    secondaryNationality: NationalityDto;
    maritialStatus: number;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
    spouse: ReadSpouseDto[] | undefined;
    children: ReadChildrenDto[] | undefined;
    dependents: ReadDependentDto[] | undefined;
    educations: ReadEducationDto[] | undefined;
    trainings: ReadTrainingDto[] | undefined;
    experiences: ReadExperienceDto[] | undefined;
    skills: ReadSkillDto[] | undefined;
    languages: ReadLanguageDto[] | undefined;
    certificates: ReadCertificateDto[] | undefined;
    militaryService: ReadMilitaryServiceDto[] | undefined;
    passports: ReadPassportDto[] | undefined;
    driverLicense: ReadDriverLicenseDto[] | undefined;
    convictions: ReadConvictionDto[] | undefined;
    residences: ReadResidencyDto[] | undefined;
    positions: ReadPositionDto[] | undefined;
    bloodType: number;
    userId: number;
    user: UserDto;
}

export class ReadEmployeeDtoPagedResultDto implements IReadEmployeeDtoPagedResultDto {
    items: ReadEmployeeDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadEmployeeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadEmployeeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadEmployeeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEmployeeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadEmployeeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadEmployeeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadEmployeeDtoPagedResultDto {
    items: ReadEmployeeDto[] | undefined;
    totalCount: number;
}

export class ReadEntranceExitRecordDto implements IReadEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    readonly day: string | undefined;
    employeeId: string;
    employee: ReadEmployeeDto;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;

    constructor(data?: IReadEntranceExitRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.logDate = _data["logDate"];
            (<any>this).day = _data["day"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.logTime = _data["logTime"];
            this.recordType = _data["recordType"];
            this.notes = _data["notes"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): ReadEntranceExitRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEntranceExitRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["logDate"] = this.logDate;
        data["day"] = this.day;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["logTime"] = this.logTime;
        data["recordType"] = this.recordType;
        data["notes"] = this.notes;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): ReadEntranceExitRecordDto {
        const json = this.toJSON();
        let result = new ReadEntranceExitRecordDto();
        result.init(json);
        return result;
    }
}

export interface IReadEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    day: string | undefined;
    employeeId: string;
    employee: ReadEmployeeDto;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;
}

export class ReadEntranceExitRecordDtoPagedResultDto implements IReadEntranceExitRecordDtoPagedResultDto {
    items: ReadEntranceExitRecordDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadEntranceExitRecordDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadEntranceExitRecordDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadEntranceExitRecordDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadEntranceExitRecordDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadEntranceExitRecordDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadEntranceExitRecordDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadEntranceExitRecordDtoPagedResultDto {
    items: ReadEntranceExitRecordDto[] | undefined;
    totalCount: number;
}

export class ReadExperienceDto implements IReadExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.jobTitle = _data["jobTitle"];
            this.industry = _data["industry"];
            this.companyName = _data["companyName"];
            this.companyLocation = _data["companyLocation"];
            this.companyWebSite = _data["companyWebSite"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.leaveReason = _data["leaveReason"];
            this.notes = _data["notes"];
            this.referenceFullName = _data["referenceFullName"];
            this.referenceJobTitle = _data["referenceJobTitle"];
            this.referenceContact = _data["referenceContact"];
            this.referenceEmail = _data["referenceEmail"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["jobTitle"] = this.jobTitle;
        data["industry"] = this.industry;
        data["companyName"] = this.companyName;
        data["companyLocation"] = this.companyLocation;
        data["companyWebSite"] = this.companyWebSite;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveReason"] = this.leaveReason;
        data["notes"] = this.notes;
        data["referenceFullName"] = this.referenceFullName;
        data["referenceJobTitle"] = this.referenceJobTitle;
        data["referenceContact"] = this.referenceContact;
        data["referenceEmail"] = this.referenceEmail;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadExperienceDto {
        const json = this.toJSON();
        let result = new ReadExperienceDto();
        result.init(json);
        return result;
    }
}

export interface IReadExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadExperienceDtoPagedResultDto implements IReadExperienceDtoPagedResultDto {
    items: ReadExperienceDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadExperienceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadExperienceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadExperienceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadExperienceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadExperienceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadExperienceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadExperienceDtoPagedResultDto {
    items: ReadExperienceDto[] | undefined;
    totalCount: number;
}

export class ReadFinancialCardDto implements IReadFinancialCardDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    salary: number;

    constructor(data?: IReadFinancialCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.salary = _data["salary"];
        }
    }

    static fromJS(data: any): ReadFinancialCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadFinancialCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["salary"] = this.salary;
        return data;
    }

    clone(): ReadFinancialCardDto {
        const json = this.toJSON();
        let result = new ReadFinancialCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadFinancialCardDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    salary: number;
}

export class ReadFinancialCardDtoPagedResultDto implements IReadFinancialCardDtoPagedResultDto {
    items: ReadFinancialCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadFinancialCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadFinancialCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadFinancialCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadFinancialCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadFinancialCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadFinancialCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadFinancialCardDtoPagedResultDto {
    items: ReadFinancialCardDto[] | undefined;
    totalCount: number;
}

export class ReadFixedHolidayDto implements IReadFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;

    constructor(data?: IReadFixedHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.numberofDays = _data["numberofDays"];
        }
    }

    static fromJS(data: any): ReadFixedHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadFixedHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["day"] = this.day;
        data["month"] = this.month;
        data["numberofDays"] = this.numberofDays;
        return data;
    }

    clone(): ReadFixedHolidayDto {
        const json = this.toJSON();
        let result = new ReadFixedHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IReadFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;
}

export class ReadFixedHolidayDtoPagedResultDto implements IReadFixedHolidayDtoPagedResultDto {
    items: ReadFixedHolidayDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadFixedHolidayDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadFixedHolidayDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadFixedHolidayDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadFixedHolidayDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadFixedHolidayDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadFixedHolidayDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadFixedHolidayDtoPagedResultDto {
    items: ReadFixedHolidayDto[] | undefined;
    totalCount: number;
}

export class ReadGradeDto implements IReadGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    organizationLevel: ReadOrganizationLevelDto;
    educationGradeId: string;
    educationGrade: ReadEducationGradeDto;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;

    constructor(data?: IReadGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationLevelId = _data["organizationLevelId"];
            this.organizationLevel = _data["organizationLevel"] ? ReadOrganizationLevelDto.fromJS(_data["organizationLevel"]) : <any>undefined;
            this.educationGradeId = _data["educationGradeId"];
            this.educationGrade = _data["educationGrade"] ? ReadEducationGradeDto.fromJS(_data["educationGrade"]) : <any>undefined;
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.gradeCategory = _data["gradeCategory"];
        }
    }

    static fromJS(data: any): ReadGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationLevelId"] = this.organizationLevelId;
        data["organizationLevel"] = this.organizationLevel ? this.organizationLevel.toJSON() : <any>undefined;
        data["educationGradeId"] = this.educationGradeId;
        data["educationGrade"] = this.educationGrade ? this.educationGrade.toJSON() : <any>undefined;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["gradeCategory"] = this.gradeCategory;
        return data;
    }

    clone(): ReadGradeDto {
        const json = this.toJSON();
        let result = new ReadGradeDto();
        result.init(json);
        return result;
    }
}

export interface IReadGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    organizationLevel: ReadOrganizationLevelDto;
    educationGradeId: string;
    educationGrade: ReadEducationGradeDto;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;
}

export class ReadGradeDtoPagedResultDto implements IReadGradeDtoPagedResultDto {
    items: ReadGradeDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadGradeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadGradeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadGradeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadGradeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadGradeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadGradeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadGradeDtoPagedResultDto {
    items: ReadGradeDto[] | undefined;
    totalCount: number;
}

export class ReadHourlyMissionDto implements IReadHourlyMissionDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IReadHourlyMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ReadHourlyMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadHourlyMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): ReadHourlyMissionDto {
        const json = this.toJSON();
        let result = new ReadHourlyMissionDto();
        result.init(json);
        return result;
    }
}

export interface IReadHourlyMissionDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class ReadHourlyMissionDtoPagedResultDto implements IReadHourlyMissionDtoPagedResultDto {
    items: ReadHourlyMissionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadHourlyMissionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadHourlyMissionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadHourlyMissionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadHourlyMissionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadHourlyMissionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadHourlyMissionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadHourlyMissionDtoPagedResultDto {
    items: ReadHourlyMissionDto[] | undefined;
    totalCount: number;
}

export class ReadJobDescriptionDto implements IReadJobDescriptionDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    name: string | undefined;
    nodeId: string;
    node: ReadNodeDto;
    description: string | undefined;

    constructor(data?: IReadJobDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? ReadJobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.name = _data["name"];
            this.nodeId = _data["nodeId"];
            this.node = _data["node"] ? ReadNodeDto.fromJS(_data["node"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadJobDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadJobDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["nodeId"] = this.nodeId;
        data["node"] = this.node ? this.node.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadJobDescriptionDto {
        const json = this.toJSON();
        let result = new ReadJobDescriptionDto();
        result.init(json);
        return result;
    }
}

export interface IReadJobDescriptionDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    name: string | undefined;
    nodeId: string;
    node: ReadNodeDto;
    description: string | undefined;
}

export class ReadJobDescriptionDtoPagedResultDto implements IReadJobDescriptionDtoPagedResultDto {
    items: ReadJobDescriptionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadJobDescriptionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadJobDescriptionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadJobDescriptionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadJobDescriptionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadJobDescriptionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadJobDescriptionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadJobDescriptionDtoPagedResultDto {
    items: ReadJobDescriptionDto[] | undefined;
    totalCount: number;
}

export class ReadJobTitleDto implements IReadJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
    grade: ReadGradeDto;

    constructor(data?: IReadJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.gradeId = _data["gradeId"];
            this.grade = _data["grade"] ? ReadGradeDto.fromJS(_data["grade"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReadJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["gradeId"] = this.gradeId;
        data["grade"] = this.grade ? this.grade.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReadJobTitleDto {
        const json = this.toJSON();
        let result = new ReadJobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IReadJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
    grade: ReadGradeDto;
}

export class ReadJobTitleDtoPagedResultDto implements IReadJobTitleDtoPagedResultDto {
    items: ReadJobTitleDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadJobTitleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadJobTitleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadJobTitleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadJobTitleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadJobTitleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadJobTitleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadJobTitleDtoPagedResultDto {
    items: ReadJobTitleDto[] | undefined;
    totalCount: number;
}

export class ReadLanguageDto implements IReadLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    languageName: LanguageNameDto;
    writingId: string;
    writing: LevelDto;
    readingId: string;
    reading: LevelDto;
    speakingId: string;
    speaking: LevelDto;
    listeningId: string;
    listening: LevelDto;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.languageNameId = _data["languageNameId"];
            this.languageName = _data["languageName"] ? LanguageNameDto.fromJS(_data["languageName"]) : <any>undefined;
            this.writingId = _data["writingId"];
            this.writing = _data["writing"] ? LevelDto.fromJS(_data["writing"]) : <any>undefined;
            this.readingId = _data["readingId"];
            this.reading = _data["reading"] ? LevelDto.fromJS(_data["reading"]) : <any>undefined;
            this.speakingId = _data["speakingId"];
            this.speaking = _data["speaking"] ? LevelDto.fromJS(_data["speaking"]) : <any>undefined;
            this.listeningId = _data["listeningId"];
            this.listening = _data["listening"] ? LevelDto.fromJS(_data["listening"]) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["languageNameId"] = this.languageNameId;
        data["languageName"] = this.languageName ? this.languageName.toJSON() : <any>undefined;
        data["writingId"] = this.writingId;
        data["writing"] = this.writing ? this.writing.toJSON() : <any>undefined;
        data["readingId"] = this.readingId;
        data["reading"] = this.reading ? this.reading.toJSON() : <any>undefined;
        data["speakingId"] = this.speakingId;
        data["speaking"] = this.speaking ? this.speaking.toJSON() : <any>undefined;
        data["listeningId"] = this.listeningId;
        data["listening"] = this.listening ? this.listening.toJSON() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadLanguageDto {
        const json = this.toJSON();
        let result = new ReadLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IReadLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    languageName: LanguageNameDto;
    writingId: string;
    writing: LevelDto;
    readingId: string;
    reading: LevelDto;
    speakingId: string;
    speaking: LevelDto;
    listeningId: string;
    listening: LevelDto;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadLanguageDtoPagedResultDto implements IReadLanguageDtoPagedResultDto {
    items: ReadLanguageDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadLanguageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadLanguageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadLanguageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLanguageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadLanguageDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadLanguageDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadLanguageDtoPagedResultDto {
    items: ReadLanguageDto[] | undefined;
    totalCount: number;
}

export class ReadLeaveRequestDto implements IReadLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    leaveSetting: ReadLeaveSettingDto;
    employeeId: string;
    employee: ReadEmployeeDto;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    leaveRequestStatus: number;
    readonly leaveRequestBalance: number;
    description: string | undefined;

    constructor(data?: IReadLeaveRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.leaveSettingId = _data["leaveSettingId"];
            this.leaveSetting = _data["leaveSetting"] ? ReadLeaveSettingDto.fromJS(_data["leaveSetting"]) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.requestDate = _data["requestDate"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.isHourly = _data["isHourly"];
            this.startHour = _data["startHour"];
            this.endHour = _data["endHour"];
            this.leaveRequestStatus = _data["leaveRequestStatus"];
            (<any>this).leaveRequestBalance = _data["leaveRequestBalance"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadLeaveRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLeaveRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["leaveSettingId"] = this.leaveSettingId;
        data["leaveSetting"] = this.leaveSetting ? this.leaveSetting.toJSON() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["requestDate"] = this.requestDate;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["isHourly"] = this.isHourly;
        data["startHour"] = this.startHour;
        data["endHour"] = this.endHour;
        data["leaveRequestStatus"] = this.leaveRequestStatus;
        data["leaveRequestBalance"] = this.leaveRequestBalance;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadLeaveRequestDto {
        const json = this.toJSON();
        let result = new ReadLeaveRequestDto();
        result.init(json);
        return result;
    }
}

export interface IReadLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    leaveSetting: ReadLeaveSettingDto;
    employeeId: string;
    employee: ReadEmployeeDto;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    leaveRequestStatus: number;
    leaveRequestBalance: number;
    description: string | undefined;
}

export class ReadLeaveRequestDtoPagedResultDto implements IReadLeaveRequestDtoPagedResultDto {
    items: ReadLeaveRequestDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadLeaveRequestDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadLeaveRequestDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadLeaveRequestDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLeaveRequestDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadLeaveRequestDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadLeaveRequestDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadLeaveRequestDtoPagedResultDto {
    items: ReadLeaveRequestDto[] | undefined;
    totalCount: number;
}

export class ReadLeaveSettingDto implements IReadLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    workflowSetting: ReadWorkflowSettingDto;
    description: string | undefined;

    constructor(data?: IReadLeaveSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.isPaidLeave = _data["isPaidLeave"];
            this.workflowSettingId = _data["workflowSettingId"];
            this.workflowSetting = _data["workflowSetting"] ? ReadWorkflowSettingDto.fromJS(_data["workflowSetting"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadLeaveSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLeaveSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["isPaidLeave"] = this.isPaidLeave;
        data["workflowSettingId"] = this.workflowSettingId;
        data["workflowSetting"] = this.workflowSetting ? this.workflowSetting.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadLeaveSettingDto {
        const json = this.toJSON();
        let result = new ReadLeaveSettingDto();
        result.init(json);
        return result;
    }
}

export interface IReadLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    workflowSetting: ReadWorkflowSettingDto;
    description: string | undefined;
}

export class ReadLeaveSettingDtoPagedResultDto implements IReadLeaveSettingDtoPagedResultDto {
    items: ReadLeaveSettingDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadLeaveSettingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadLeaveSettingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadLeaveSettingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadLeaveSettingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadLeaveSettingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadLeaveSettingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadLeaveSettingDtoPagedResultDto {
    items: ReadLeaveSettingDto[] | undefined;
    totalCount: number;
}

export class ReadMilitaryServiceDto implements IReadMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadMilitaryServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.militaryStatus = _data["militaryStatus"];
            this.isPermanentExemption = _data["isPermanentExemption"];
            this.exemptionReason = _data["exemptionReason"];
            this.exemptionDate = _data["exemptionDate"] ? moment(_data["exemptionDate"].toString()) : <any>undefined;
            this.delayReason = _data["delayReason"];
            this.delayDate = _data["delayDate"] ? moment(_data["delayDate"].toString()) : <any>undefined;
            this.militaryServiceNo = _data["militaryServiceNo"];
            this.militaryServiceDocIssueDate = _data["militaryServiceDocIssueDate"] ? moment(_data["militaryServiceDocIssueDate"].toString()) : <any>undefined;
            this.granter = _data["granter"];
            this.years = _data["years"];
            this.months = _data["months"];
            this.days = _data["days"];
            this.serviceStartDate = _data["serviceStartDate"] ? moment(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? moment(_data["serviceEndDate"].toString()) : <any>undefined;
            this.holdDate = _data["holdDate"] ? moment(_data["holdDate"].toString()) : <any>undefined;
            this.reserveStartDate = _data["reserveStartDate"] ? moment(_data["reserveStartDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadMilitaryServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMilitaryServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["militaryStatus"] = this.militaryStatus;
        data["isPermanentExemption"] = this.isPermanentExemption;
        data["exemptionReason"] = this.exemptionReason;
        data["exemptionDate"] = this.exemptionDate ? this.exemptionDate.toISOString() : <any>undefined;
        data["delayReason"] = this.delayReason;
        data["delayDate"] = this.delayDate ? this.delayDate.toISOString() : <any>undefined;
        data["militaryServiceNo"] = this.militaryServiceNo;
        data["militaryServiceDocIssueDate"] = this.militaryServiceDocIssueDate ? this.militaryServiceDocIssueDate.toISOString() : <any>undefined;
        data["granter"] = this.granter;
        data["years"] = this.years;
        data["months"] = this.months;
        data["days"] = this.days;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toISOString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toISOString() : <any>undefined;
        data["holdDate"] = this.holdDate ? this.holdDate.toISOString() : <any>undefined;
        data["reserveStartDate"] = this.reserveStartDate ? this.reserveStartDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadMilitaryServiceDto {
        const json = this.toJSON();
        let result = new ReadMilitaryServiceDto();
        result.init(json);
        return result;
    }
}

export interface IReadMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadMilitaryServiceDtoPagedResultDto implements IReadMilitaryServiceDtoPagedResultDto {
    items: ReadMilitaryServiceDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadMilitaryServiceDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadMilitaryServiceDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadMilitaryServiceDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMilitaryServiceDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadMilitaryServiceDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadMilitaryServiceDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadMilitaryServiceDtoPagedResultDto {
    items: ReadMilitaryServiceDto[] | undefined;
    totalCount: number;
}

export class ReadMonthDto implements IReadMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;

    constructor(data?: IReadMonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.monthName = _data["monthName"];
            this.title = _data["title"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): ReadMonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["monthName"] = this.monthName;
        data["title"] = this.title;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): ReadMonthDto {
        const json = this.toJSON();
        let result = new ReadMonthDto();
        result.init(json);
        return result;
    }
}

export interface IReadMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;
}

export class ReadMonthDtoPagedResultDto implements IReadMonthDtoPagedResultDto {
    items: ReadMonthDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadMonthDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadMonthDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadMonthDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMonthDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadMonthDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadMonthDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadMonthDtoPagedResultDto {
    items: ReadMonthDto[] | undefined;
    totalCount: number;
}

export class ReadMonthlyCardDto implements IReadMonthlyCardDto {
    id: string;
    employeeCardId: string;
    employeeCard: ReadEmployeeCardDto;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;
    benefitCards: ReadBenefitCardDto[] | undefined;
    deductionCards: ReadDeductionCardDto[] | undefined;

    constructor(data?: IReadMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? ReadEmployeeCardDto.fromJS(_data["employeeCard"]) : <any>undefined;
            this.salary = _data["salary"];
            this.calculated = _data["calculated"];
            this.workDays = _data["workDays"];
            this.totalDeductions = _data["totalDeductions"];
            this.totalBenefits = _data["totalBenefits"];
            this.finalSalary = _data["finalSalary"];
            if (Array.isArray(_data["benefitCards"])) {
                this.benefitCards = [] as any;
                for (let item of _data["benefitCards"])
                    this.benefitCards.push(ReadBenefitCardDto.fromJS(item));
            }
            if (Array.isArray(_data["deductionCards"])) {
                this.deductionCards = [] as any;
                for (let item of _data["deductionCards"])
                    this.deductionCards.push(ReadDeductionCardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["salary"] = this.salary;
        data["calculated"] = this.calculated;
        data["workDays"] = this.workDays;
        data["totalDeductions"] = this.totalDeductions;
        data["totalBenefits"] = this.totalBenefits;
        data["finalSalary"] = this.finalSalary;
        if (Array.isArray(this.benefitCards)) {
            data["benefitCards"] = [];
            for (let item of this.benefitCards)
                data["benefitCards"].push(item.toJSON());
        }
        if (Array.isArray(this.deductionCards)) {
            data["deductionCards"] = [];
            for (let item of this.deductionCards)
                data["deductionCards"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadMonthlyCardDto {
        const json = this.toJSON();
        let result = new ReadMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IReadMonthlyCardDto {
    id: string;
    employeeCardId: string;
    employeeCard: ReadEmployeeCardDto;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;
    benefitCards: ReadBenefitCardDto[] | undefined;
    deductionCards: ReadDeductionCardDto[] | undefined;
}

export class ReadMonthlyCardDtoPagedResultDto implements IReadMonthlyCardDtoPagedResultDto {
    items: ReadMonthlyCardDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadMonthlyCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadMonthlyCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadMonthlyCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadMonthlyCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadMonthlyCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadMonthlyCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadMonthlyCardDtoPagedResultDto {
    items: ReadMonthlyCardDto[] | undefined;
    totalCount: number;
}

export class ReadNodeDto implements IReadNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    parent: ReadNodeDto;
    code: string | undefined;
    isRoot: boolean;

    constructor(data?: IReadNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.parent = _data["parent"] ? ReadNodeDto.fromJS(_data["parent"]) : <any>undefined;
            this.code = _data["code"];
            this.isRoot = _data["isRoot"];
        }
    }

    static fromJS(data: any): ReadNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["isRoot"] = this.isRoot;
        return data;
    }

    clone(): ReadNodeDto {
        const json = this.toJSON();
        let result = new ReadNodeDto();
        result.init(json);
        return result;
    }
}

export interface IReadNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    parent: ReadNodeDto;
    code: string | undefined;
    isRoot: boolean;
}

export class ReadNodeDtoPagedResultDto implements IReadNodeDtoPagedResultDto {
    items: ReadNodeDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadNodeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadNodeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadNodeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadNodeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadNodeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadNodeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadNodeDtoPagedResultDto {
    items: ReadNodeDto[] | undefined;
    totalCount: number;
}

export class ReadNormalShiftDto implements IReadNormalShiftDto {
    id: string;
    entryTime: string | undefined;
    workshopId: string;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;

    constructor(data?: IReadNormalShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entryTime = _data["entryTime"];
            this.workshopId = _data["workshopId"];
            this.exitTime = _data["exitTime"];
            this.shiftRangeStartTime = _data["shiftRangeStartTime"];
            this.shiftRangeEndTime = _data["shiftRangeEndTime"];
        }
    }

    static fromJS(data: any): ReadNormalShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadNormalShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entryTime"] = this.entryTime;
        data["workshopId"] = this.workshopId;
        data["exitTime"] = this.exitTime;
        data["shiftRangeStartTime"] = this.shiftRangeStartTime;
        data["shiftRangeEndTime"] = this.shiftRangeEndTime;
        return data;
    }

    clone(): ReadNormalShiftDto {
        const json = this.toJSON();
        let result = new ReadNormalShiftDto();
        result.init(json);
        return result;
    }
}

export interface IReadNormalShiftDto {
    id: string;
    entryTime: string | undefined;
    workshopId: string;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;
}

export class ReadNormalShiftDtoPagedResultDto implements IReadNormalShiftDtoPagedResultDto {
    items: ReadNormalShiftDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadNormalShiftDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadNormalShiftDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadNormalShiftDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadNormalShiftDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadNormalShiftDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadNormalShiftDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadNormalShiftDtoPagedResultDto {
    items: ReadNormalShiftDto[] | undefined;
    totalCount: number;
}

export class ReadOrganizationLevelDto implements IReadOrganizationLevelDto {
    id: string;
    name: string | undefined;

    constructor(data?: IReadOrganizationLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReadOrganizationLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadOrganizationLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ReadOrganizationLevelDto {
        const json = this.toJSON();
        let result = new ReadOrganizationLevelDto();
        result.init(json);
        return result;
    }
}

export interface IReadOrganizationLevelDto {
    id: string;
    name: string | undefined;
}

export class ReadOrganizationLevelDtoPagedResultDto implements IReadOrganizationLevelDtoPagedResultDto {
    items: ReadOrganizationLevelDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadOrganizationLevelDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadOrganizationLevelDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadOrganizationLevelDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadOrganizationLevelDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadOrganizationLevelDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadOrganizationLevelDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadOrganizationLevelDtoPagedResultDto {
    items: ReadOrganizationLevelDto[] | undefined;
    totalCount: number;
}

export class ReadPassportDto implements IReadPassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    placeofIssuance: CityDto;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadPassportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.placeofIssuance = _data["placeofIssuance"] ? CityDto.fromJS(_data["placeofIssuance"]) : <any>undefined;
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadPassportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPassportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["placeofIssuance"] = this.placeofIssuance ? this.placeofIssuance.toJSON() : <any>undefined;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadPassportDto {
        const json = this.toJSON();
        let result = new ReadPassportDto();
        result.init(json);
        return result;
    }
}

export interface IReadPassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    placeofIssuance: CityDto;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadPassportDtoPagedResultDto implements IReadPassportDtoPagedResultDto {
    items: ReadPassportDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadPassportDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadPassportDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadPassportDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPassportDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadPassportDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadPassportDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadPassportDtoPagedResultDto {
    items: ReadPassportDto[] | undefined;
    totalCount: number;
}

export class ReadPositionDto implements IReadPositionDto {
    id: string;
    jobDescriptionId: string;
    jobDescription: ReadJobDescriptionDto;
    positionWorkTypeId: string;
    positionWorkType: ReadPositionWorkTypeDto;
    workingHours: number;
    per: HoursPer;
    hasManager: boolean;
    managerId: string | undefined;
    manager: ReadPositionDto;

    constructor(data?: IReadPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.jobDescription = _data["jobDescription"] ? ReadJobDescriptionDto.fromJS(_data["jobDescription"]) : <any>undefined;
            this.positionWorkTypeId = _data["positionWorkTypeId"];
            this.positionWorkType = _data["positionWorkType"] ? ReadPositionWorkTypeDto.fromJS(_data["positionWorkType"]) : <any>undefined;
            this.workingHours = _data["workingHours"];
            this.per = _data["per"];
            this.hasManager = _data["hasManager"];
            this.managerId = _data["managerId"];
            this.manager = _data["manager"] ? ReadPositionDto.fromJS(_data["manager"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReadPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["jobDescription"] = this.jobDescription ? this.jobDescription.toJSON() : <any>undefined;
        data["positionWorkTypeId"] = this.positionWorkTypeId;
        data["positionWorkType"] = this.positionWorkType ? this.positionWorkType.toJSON() : <any>undefined;
        data["workingHours"] = this.workingHours;
        data["per"] = this.per;
        data["hasManager"] = this.hasManager;
        data["managerId"] = this.managerId;
        data["manager"] = this.manager ? this.manager.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReadPositionDto {
        const json = this.toJSON();
        let result = new ReadPositionDto();
        result.init(json);
        return result;
    }
}

export interface IReadPositionDto {
    id: string;
    jobDescriptionId: string;
    jobDescription: ReadJobDescriptionDto;
    positionWorkTypeId: string;
    positionWorkType: ReadPositionWorkTypeDto;
    workingHours: number;
    per: HoursPer;
    hasManager: boolean;
    managerId: string | undefined;
    manager: ReadPositionDto;
}

export class ReadPositionDtoPagedResultDto implements IReadPositionDtoPagedResultDto {
    items: ReadPositionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadPositionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadPositionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadPositionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPositionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadPositionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadPositionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadPositionDtoPagedResultDto {
    items: ReadPositionDto[] | undefined;
    totalCount: number;
}

export class ReadPositionWorkTypeDto implements IReadPositionWorkTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IReadPositionWorkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReadPositionWorkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPositionWorkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ReadPositionWorkTypeDto {
        const json = this.toJSON();
        let result = new ReadPositionWorkTypeDto();
        result.init(json);
        return result;
    }
}

export interface IReadPositionWorkTypeDto {
    id: string;
    name: string | undefined;
}

export class ReadPositionWorkTypeDtoPagedResultDto implements IReadPositionWorkTypeDtoPagedResultDto {
    items: ReadPositionWorkTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadPositionWorkTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadPositionWorkTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadPositionWorkTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPositionWorkTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadPositionWorkTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadPositionWorkTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadPositionWorkTypeDtoPagedResultDto {
    items: ReadPositionWorkTypeDto[] | undefined;
    totalCount: number;
}

export class ReadPromotionDto implements IReadPromotionDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    positionId: string;
    position: ReadPositionDto;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IReadPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.jobTitle = _data["jobTitle"] ? ReadJobTitleDto.fromJS(_data["jobTitle"]) : <any>undefined;
            this.positionId = _data["positionId"];
            this.position = _data["position"] ? ReadPositionDto.fromJS(_data["position"]) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.promotionDate = _data["promotionDate"] ? moment(_data["promotionDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadPromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["jobTitle"] = this.jobTitle ? this.jobTitle.toJSON() : <any>undefined;
        data["positionId"] = this.positionId;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["promotionDate"] = this.promotionDate ? this.promotionDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadPromotionDto {
        const json = this.toJSON();
        let result = new ReadPromotionDto();
        result.init(json);
        return result;
    }
}

export interface IReadPromotionDto {
    id: string;
    jobTitleId: string;
    jobTitle: ReadJobTitleDto;
    positionId: string;
    position: ReadPositionDto;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;
}

export class ReadPromotionDtoPagedResultDto implements IReadPromotionDtoPagedResultDto {
    items: ReadPromotionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadPromotionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadPromotionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadPromotionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadPromotionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadPromotionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadPromotionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadPromotionDtoPagedResultDto {
    items: ReadPromotionDto[] | undefined;
    totalCount: number;
}

export class ReadResidencyDto implements IReadResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    nationality: NationalityDto;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadResidencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.residencyType = _data["residencyType"];
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.tel = _data["tel"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadResidencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadResidencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["residencyType"] = this.residencyType;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadResidencyDto {
        const json = this.toJSON();
        let result = new ReadResidencyDto();
        result.init(json);
        return result;
    }
}

export interface IReadResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    nationality: NationalityDto;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadResidencyDtoPagedResultDto implements IReadResidencyDtoPagedResultDto {
    items: ReadResidencyDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadResidencyDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadResidencyDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadResidencyDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadResidencyDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadResidencyDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadResidencyDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadResidencyDtoPagedResultDto {
    items: ReadResidencyDto[] | undefined;
    totalCount: number;
}

export class ReadResignationDto implements IReadResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    description: string | undefined;

    constructor(data?: IReadResignationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resignationDate = _data["resignationDate"] ? moment(_data["resignationDate"].toString()) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? EmployeeCard.fromJS(_data["employeeCard"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadResignationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadResignationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resignationDate"] = this.resignationDate ? this.resignationDate.toISOString() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadResignationDto {
        const json = this.toJSON();
        let result = new ReadResignationDto();
        result.init(json);
        return result;
    }
}

export interface IReadResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    description: string | undefined;
}

export class ReadResignationDtoPagedResultDto implements IReadResignationDtoPagedResultDto {
    items: ReadResignationDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadResignationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadResignationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadResignationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadResignationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadResignationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadResignationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadResignationDtoPagedResultDto {
    items: ReadResignationDto[] | undefined;
    totalCount: number;
}

export class ReadSkillDto implements IReadSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    level: LevelDto;
    description: string | undefined;
    comments: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.skillName = _data["skillName"];
            this.levelId = _data["levelId"];
            this.level = _data["level"] ? LevelDto.fromJS(_data["level"]) : <any>undefined;
            this.description = _data["description"];
            this.comments = _data["comments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["skillName"] = this.skillName;
        data["levelId"] = this.levelId;
        data["level"] = this.level ? this.level.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["comments"] = this.comments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadSkillDto {
        const json = this.toJSON();
        let result = new ReadSkillDto();
        result.init(json);
        return result;
    }
}

export interface IReadSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    level: LevelDto;
    description: string | undefined;
    comments: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadSkillDtoPagedResultDto implements IReadSkillDtoPagedResultDto {
    items: ReadSkillDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadSkillDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadSkillDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadSkillDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadSkillDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadSkillDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadSkillDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadSkillDtoPagedResultDto {
    items: ReadSkillDto[] | undefined;
    totalCount: number;
}

export class ReadSpouseDto implements IReadSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;

    constructor(data?: IReadSpouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? CityDto.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? NationalityDto.fromJS(_data["nationality"]) : <any>undefined;
            this.residencyNo = _data["residencyNo"];
            this.residencyExpireDate = _data["residencyExpireDate"] ? moment(_data["residencyExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.firstContactNumber = _data["firstContactNumber"];
            this.secondContactNumber = _data["secondContactNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.gender = _data["gender"];
            this.order = _data["order"];
            this.marrigeDate = _data["marrigeDate"] ? moment(_data["marrigeDate"].toString()) : <any>undefined;
            this.isDivorced = _data["isDivorced"];
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            this.hasJob = _data["hasJob"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.workAddress = _data["workAddress"];
            this.workPhone = _data["workPhone"];
            this.workEmail = _data["workEmail"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(ReadAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadSpouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadSpouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residencyNo"] = this.residencyNo;
        data["residencyExpireDate"] = this.residencyExpireDate ? this.residencyExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["firstContactNumber"] = this.firstContactNumber;
        data["secondContactNumber"] = this.secondContactNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["gender"] = this.gender;
        data["order"] = this.order;
        data["marrigeDate"] = this.marrigeDate ? this.marrigeDate.toISOString() : <any>undefined;
        data["isDivorced"] = this.isDivorced;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        data["hasJob"] = this.hasJob;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["workAddress"] = this.workAddress;
        data["workPhone"] = this.workPhone;
        data["workEmail"] = this.workEmail;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadSpouseDto {
        const json = this.toJSON();
        let result = new ReadSpouseDto();
        result.init(json);
        return result;
    }
}

export interface IReadSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: CityDto;
    nationalityId: string;
    nationality: NationalityDto;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
    attachments: ReadAttachmentDto[] | undefined;
}

export class ReadSpouseDtoPagedResultDto implements IReadSpouseDtoPagedResultDto {
    items: ReadSpouseDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadSpouseDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadSpouseDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadSpouseDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadSpouseDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadSpouseDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadSpouseDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadSpouseDtoPagedResultDto {
    items: ReadSpouseDto[] | undefined;
    totalCount: number;
}

export class ReadTemporaryWorkshopDto implements IReadTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;

    constructor(data?: IReadTemporaryWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workshopId = _data["workshopId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.tempWorkshopId = _data["tempWorkshopId"];
        }
    }

    static fromJS(data: any): ReadTemporaryWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTemporaryWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workshopId"] = this.workshopId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["tempWorkshopId"] = this.tempWorkshopId;
        return data;
    }

    clone(): ReadTemporaryWorkshopDto {
        const json = this.toJSON();
        let result = new ReadTemporaryWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IReadTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;
}

export class ReadTemporaryWorkshopDtoPagedResultDto implements IReadTemporaryWorkshopDtoPagedResultDto {
    items: ReadTemporaryWorkshopDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadTemporaryWorkshopDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadTemporaryWorkshopDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadTemporaryWorkshopDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTemporaryWorkshopDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadTemporaryWorkshopDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadTemporaryWorkshopDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadTemporaryWorkshopDtoPagedResultDto {
    items: ReadTemporaryWorkshopDto[] | undefined;
    totalCount: number;
}

export class ReadTrainingDto implements IReadTrainingDto {
    id: string;

    constructor(data?: IReadTrainingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReadTrainingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTrainingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): ReadTrainingDto {
        const json = this.toJSON();
        let result = new ReadTrainingDto();
        result.init(json);
        return result;
    }
}

export interface IReadTrainingDto {
    id: string;
}

export class ReadTrainingDtoPagedResultDto implements IReadTrainingDtoPagedResultDto {
    items: ReadTrainingDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadTrainingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadTrainingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadTrainingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTrainingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadTrainingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadTrainingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadTrainingDtoPagedResultDto {
    items: ReadTrainingDto[] | undefined;
    totalCount: number;
}

export class ReadTransferDto implements IReadTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationJobTitle: ReadJobTitleDto;
    destinationPositionId: string;
    destinationPosition: ReadPositionDto;
    startingDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IReadTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.destinationJobTitleId = _data["destinationJobTitleId"];
            this.destinationJobTitle = _data["destinationJobTitle"] ? ReadJobTitleDto.fromJS(_data["destinationJobTitle"]) : <any>undefined;
            this.destinationPositionId = _data["destinationPositionId"];
            this.destinationPosition = _data["destinationPosition"] ? ReadPositionDto.fromJS(_data["destinationPosition"]) : <any>undefined;
            this.startingDate = _data["startingDate"] ? moment(_data["startingDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ReadTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["destinationJobTitleId"] = this.destinationJobTitleId;
        data["destinationJobTitle"] = this.destinationJobTitle ? this.destinationJobTitle.toJSON() : <any>undefined;
        data["destinationPositionId"] = this.destinationPositionId;
        data["destinationPosition"] = this.destinationPosition ? this.destinationPosition.toJSON() : <any>undefined;
        data["startingDate"] = this.startingDate ? this.startingDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): ReadTransferDto {
        const json = this.toJSON();
        let result = new ReadTransferDto();
        result.init(json);
        return result;
    }
}

export interface IReadTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationJobTitle: ReadJobTitleDto;
    destinationPositionId: string;
    destinationPosition: ReadPositionDto;
    startingDate: moment.Moment;
    description: string | undefined;
}

export class ReadTransferDtoPagedResultDto implements IReadTransferDtoPagedResultDto {
    items: ReadTransferDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadTransferDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadTransferDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadTransferDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTransferDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadTransferDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadTransferDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadTransferDtoPagedResultDto {
    items: ReadTransferDto[] | undefined;
    totalCount: number;
}

export class ReadTravelMissionDto implements IReadTravelMissionDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IReadTravelMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? ReadEmployeeDto.fromJS(_data["employee"]) : <any>undefined;
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ReadTravelMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTravelMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): ReadTravelMissionDto {
        const json = this.toJSON();
        let result = new ReadTravelMissionDto();
        result.init(json);
        return result;
    }
}

export interface IReadTravelMissionDto {
    id: string;
    employeeId: string;
    employee: ReadEmployeeDto;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class ReadTravelMissionDtoPagedResultDto implements IReadTravelMissionDtoPagedResultDto {
    items: ReadTravelMissionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadTravelMissionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadTravelMissionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadTravelMissionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadTravelMissionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadTravelMissionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadTravelMissionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadTravelMissionDtoPagedResultDto {
    items: ReadTravelMissionDto[] | undefined;
    totalCount: number;
}

export class ReadWorkflowDto implements IReadWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    creator: UserDto;
    firstUserId: number;
    firstUser: UserDto;
    currentUserId: number;
    currentUser: UserDto;
    targetUserId: number;
    targetUser: UserDto;

    constructor(data?: IReadWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? UserDto.fromJS(_data["creator"]) : <any>undefined;
            this.firstUserId = _data["firstUserId"];
            this.firstUser = _data["firstUser"] ? UserDto.fromJS(_data["firstUser"]) : <any>undefined;
            this.currentUserId = _data["currentUserId"];
            this.currentUser = _data["currentUser"] ? UserDto.fromJS(_data["currentUser"]) : <any>undefined;
            this.targetUserId = _data["targetUserId"];
            this.targetUser = _data["targetUser"] ? UserDto.fromJS(_data["targetUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReadWorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["description"] = this.description;
        data["status"] = this.status;
        data["type"] = this.type;
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["firstUserId"] = this.firstUserId;
        data["firstUser"] = this.firstUser ? this.firstUser.toJSON() : <any>undefined;
        data["currentUserId"] = this.currentUserId;
        data["currentUser"] = this.currentUser ? this.currentUser.toJSON() : <any>undefined;
        data["targetUserId"] = this.targetUserId;
        data["targetUser"] = this.targetUser ? this.targetUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): ReadWorkflowDto {
        const json = this.toJSON();
        let result = new ReadWorkflowDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    creator: UserDto;
    firstUserId: number;
    firstUser: UserDto;
    currentUserId: number;
    currentUser: UserDto;
    targetUserId: number;
    targetUser: UserDto;
}

export class ReadWorkflowDtoPagedResultDto implements IReadWorkflowDtoPagedResultDto {
    items: ReadWorkflowDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadWorkflowDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadWorkflowDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadWorkflowDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkflowDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadWorkflowDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadWorkflowDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkflowDtoPagedResultDto {
    items: ReadWorkflowDto[] | undefined;
    totalCount: number;
}

export class ReadWorkflowSettingDto implements IReadWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;

    constructor(data?: IReadWorkflowSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.steps = _data["steps"];
        }
    }

    static fromJS(data: any): ReadWorkflowSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkflowSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["steps"] = this.steps;
        return data;
    }

    clone(): ReadWorkflowSettingDto {
        const json = this.toJSON();
        let result = new ReadWorkflowSettingDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;
}

export class ReadWorkflowSettingDtoPagedResultDto implements IReadWorkflowSettingDtoPagedResultDto {
    items: ReadWorkflowSettingDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadWorkflowSettingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadWorkflowSettingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadWorkflowSettingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkflowSettingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadWorkflowSettingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadWorkflowSettingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkflowSettingDtoPagedResultDto {
    items: ReadWorkflowSettingDto[] | undefined;
    totalCount: number;
}

export class ReadWorkshopDto implements IReadWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;
    normalShifts: ReadNormalShiftDto[] | undefined;

    constructor(data?: IReadWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.attendanceFormId = _data["attendanceFormId"];
            if (Array.isArray(_data["normalShifts"])) {
                this.normalShifts = [] as any;
                for (let item of _data["normalShifts"])
                    this.normalShifts.push(ReadNormalShiftDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReadWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["attendanceFormId"] = this.attendanceFormId;
        if (Array.isArray(this.normalShifts)) {
            data["normalShifts"] = [];
            for (let item of this.normalShifts)
                data["normalShifts"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReadWorkshopDto {
        const json = this.toJSON();
        let result = new ReadWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;
    normalShifts: ReadNormalShiftDto[] | undefined;
}

export class ReadWorkshopDtoPagedResultDto implements IReadWorkshopDtoPagedResultDto {
    items: ReadWorkshopDto[] | undefined;
    totalCount: number;

    constructor(data?: IReadWorkshopDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReadWorkshopDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReadWorkshopDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadWorkshopDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReadWorkshopDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReadWorkshopDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReadWorkshopDtoPagedResultDto {
    items: ReadWorkshopDto[] | undefined;
    totalCount: number;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class Religion implements IReligion {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IReligion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Religion {
        data = typeof data === 'object' ? data : {};
        let result = new Religion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Religion {
        const json = this.toJSON();
        let result = new Religion();
        result.init(json);
        return result;
    }
}

export interface IReligion {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class ReligionDto implements IReligionDto {
    id: string;
    name: string | undefined;

    constructor(data?: IReligionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ReligionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ReligionDto {
        const json = this.toJSON();
        let result = new ReligionDto();
        result.init(json);
        return result;
    }
}

export interface IReligionDto {
    id: string;
    name: string | undefined;
}

export class ReligionDtoPagedResultDto implements IReligionDtoPagedResultDto {
    items: ReligionDto[] | undefined;
    totalCount: number;

    constructor(data?: IReligionDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ReligionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReligionDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReligionDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReligionDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReligionDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReligionDtoPagedResultDto {
    items: ReligionDto[] | undefined;
    totalCount: number;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class Residency implements IResidency {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    nationality: Nationality;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: IResidency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.residencyType = _data["residencyType"];
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? Nationality.fromJS(_data["nationality"]) : <any>undefined;
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.tel = _data["tel"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Residency {
        data = typeof data === 'object' ? data : {};
        let result = new Residency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["residencyType"] = this.residencyType;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Residency {
        const json = this.toJSON();
        let result = new Residency();
        result.init(json);
        return result;
    }
}

export interface IResidency {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    nationality: Nationality;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
    attachments: Attachment[] | undefined;
}

export enum ResidencyType {
    _0 = 0,
    _1 = 1,
}

export class Resignation implements IResignation {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    resignationDate: moment.Moment;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    description: string | undefined;

    constructor(data?: IResignation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.resignationDate = _data["resignationDate"] ? moment(_data["resignationDate"].toString()) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.employeeCard = _data["employeeCard"] ? EmployeeCard.fromJS(_data["employeeCard"]) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Resignation {
        data = typeof data === 'object' ? data : {};
        let result = new Resignation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["resignationDate"] = this.resignationDate ? this.resignationDate.toISOString() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["employeeCard"] = this.employeeCard ? this.employeeCard.toJSON() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): Resignation {
        const json = this.toJSON();
        let result = new Resignation();
        result.init(json);
        return result;
    }
}

export interface IResignation {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    resignationDate: moment.Moment;
    employeeCardId: string;
    employeeCard: EmployeeCard;
    description: string | undefined;
}

export class RoleDto implements IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class Score implements IScore {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IScore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Score {
        data = typeof data === 'object' ? data : {};
        let result = new Score();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): Score {
        const json = this.toJSON();
        let result = new Score();
        result.init(json);
        return result;
    }
}

export interface IScore {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class ScoreDto implements IScoreDto {
    id: string;
    name: string | undefined;

    constructor(data?: IScoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ScoreDto {
        const json = this.toJSON();
        let result = new ScoreDto();
        result.init(json);
        return result;
    }
}

export interface IScoreDto {
    id: string;
    name: string | undefined;
}

export class ScoreType implements IScoreType {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IScoreType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScoreType {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): ScoreType {
        const json = this.toJSON();
        let result = new ScoreType();
        result.init(json);
        return result;
    }
}

export interface IScoreType {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class ScoreTypeDto implements IScoreTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IScoreTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScoreTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ScoreTypeDto {
        const json = this.toJSON();
        let result = new ScoreTypeDto();
        result.init(json);
        return result;
    }
}

export interface IScoreTypeDto {
    id: string;
    name: string | undefined;
}

export class ScoreTypeDtoPagedResultDto implements IScoreTypeDtoPagedResultDto {
    items: ScoreTypeDto[] | undefined;
    totalCount: number;

    constructor(data?: IScoreTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(ScoreTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ScoreTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ScoreTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ScoreTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IScoreTypeDtoPagedResultDto {
    items: ScoreTypeDto[] | undefined;
    totalCount: number;
}

export class Setting implements ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export class Skill implements ISkill {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    skillName: string | undefined;
    levelId: string;
    level: Level;
    description: string | undefined;
    comments: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: ISkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.skillName = _data["skillName"];
            this.levelId = _data["levelId"];
            this.level = _data["level"] ? Level.fromJS(_data["level"]) : <any>undefined;
            this.description = _data["description"];
            this.comments = _data["comments"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["skillName"] = this.skillName;
        data["levelId"] = this.levelId;
        data["level"] = this.level ? this.level.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["comments"] = this.comments;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Skill {
        const json = this.toJSON();
        let result = new Skill();
        result.init(json);
        return result;
    }
}

export interface ISkill {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    skillName: string | undefined;
    levelId: string;
    level: Level;
    description: string | undefined;
    comments: string | undefined;
    attachments: Attachment[] | undefined;
}

export class Spouse implements ISpouse {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: Gender;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: ISpouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.placeofBirth = _data["placeofBirth"] ? City.fromJS(_data["placeofBirth"]) : <any>undefined;
            this.nationalityId = _data["nationalityId"];
            this.nationality = _data["nationality"] ? Nationality.fromJS(_data["nationality"]) : <any>undefined;
            this.residencyNo = _data["residencyNo"];
            this.residencyExpireDate = _data["residencyExpireDate"] ? moment(_data["residencyExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.firstContactNumber = _data["firstContactNumber"];
            this.secondContactNumber = _data["secondContactNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.gender = _data["gender"];
            this.order = _data["order"];
            this.marrigeDate = _data["marrigeDate"] ? moment(_data["marrigeDate"].toString()) : <any>undefined;
            this.isDivorced = _data["isDivorced"];
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            this.hasJob = _data["hasJob"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.workAddress = _data["workAddress"];
            this.workPhone = _data["workPhone"];
            this.workEmail = _data["workEmail"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Spouse {
        data = typeof data === 'object' ? data : {};
        let result = new Spouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["placeofBirth"] = this.placeofBirth ? this.placeofBirth.toJSON() : <any>undefined;
        data["nationalityId"] = this.nationalityId;
        data["nationality"] = this.nationality ? this.nationality.toJSON() : <any>undefined;
        data["residencyNo"] = this.residencyNo;
        data["residencyExpireDate"] = this.residencyExpireDate ? this.residencyExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["firstContactNumber"] = this.firstContactNumber;
        data["secondContactNumber"] = this.secondContactNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["gender"] = this.gender;
        data["order"] = this.order;
        data["marrigeDate"] = this.marrigeDate ? this.marrigeDate.toISOString() : <any>undefined;
        data["isDivorced"] = this.isDivorced;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        data["hasJob"] = this.hasJob;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["workAddress"] = this.workAddress;
        data["workPhone"] = this.workPhone;
        data["workEmail"] = this.workEmail;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Spouse {
        const json = this.toJSON();
        let result = new Spouse();
        result.init(json);
        return result;
    }
}

export interface ISpouse {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    placeofBirth: City;
    nationalityId: string;
    nationality: Nationality;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: Gender;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
    attachments: Attachment[] | undefined;
}

export enum Status {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class Training implements ITraining {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    specialize: string | undefined;
    courseName: string | undefined;
    courseStartDate: moment.Moment | undefined;
    courseEndDate: moment.Moment | undefined;
    courseDurationPerHour: number | undefined;
    trainingCenter: string | undefined;
    trainingCenterLocation: string | undefined;
    instructor: string | undefined;
    instructorPhone: string | undefined;
    certificateIssuanceDate: moment.Moment | undefined;
    isActive: boolean;
    notes: string | undefined;
    attachments: Attachment[] | undefined;

    constructor(data?: ITraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.employeeId = _data["employeeId"];
            this.employee = _data["employee"] ? Employee.fromJS(_data["employee"]) : <any>undefined;
            this.specialize = _data["specialize"];
            this.courseName = _data["courseName"];
            this.courseStartDate = _data["courseStartDate"] ? moment(_data["courseStartDate"].toString()) : <any>undefined;
            this.courseEndDate = _data["courseEndDate"] ? moment(_data["courseEndDate"].toString()) : <any>undefined;
            this.courseDurationPerHour = _data["courseDurationPerHour"];
            this.trainingCenter = _data["trainingCenter"];
            this.trainingCenterLocation = _data["trainingCenterLocation"];
            this.instructor = _data["instructor"];
            this.instructorPhone = _data["instructorPhone"];
            this.certificateIssuanceDate = _data["certificateIssuanceDate"] ? moment(_data["certificateIssuanceDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments.push(Attachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["employeeId"] = this.employeeId;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["specialize"] = this.specialize;
        data["courseName"] = this.courseName;
        data["courseStartDate"] = this.courseStartDate ? this.courseStartDate.toISOString() : <any>undefined;
        data["courseEndDate"] = this.courseEndDate ? this.courseEndDate.toISOString() : <any>undefined;
        data["courseDurationPerHour"] = this.courseDurationPerHour;
        data["trainingCenter"] = this.trainingCenter;
        data["trainingCenterLocation"] = this.trainingCenterLocation;
        data["instructor"] = this.instructor;
        data["instructorPhone"] = this.instructorPhone;
        data["certificateIssuanceDate"] = this.certificateIssuanceDate ? this.certificateIssuanceDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["notes"] = this.notes;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Training {
        const json = this.toJSON();
        let result = new Training();
        result.init(json);
        return result;
    }
}

export interface ITraining {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    employeeId: string;
    employee: Employee;
    specialize: string | undefined;
    courseName: string | undefined;
    courseStartDate: moment.Moment | undefined;
    courseEndDate: moment.Moment | undefined;
    courseDurationPerHour: number | undefined;
    trainingCenter: string | undefined;
    trainingCenterLocation: string | undefined;
    instructor: string | undefined;
    instructorPhone: string | undefined;
    certificateIssuanceDate: moment.Moment | undefined;
    isActive: boolean;
    notes: string | undefined;
    attachments: Attachment[] | undefined;
}

export class Transfer implements ITransfer {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    destinationJobTitleId: string;
    destinationJobTitle: JobTitle;
    destinationPositionId: string;
    destinationPosition: Position;
    startingDate: moment.Moment;
    description: string | undefined;

    constructor(data?: ITransfer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.destinationJobTitleId = _data["destinationJobTitleId"];
            this.destinationJobTitle = _data["destinationJobTitle"] ? JobTitle.fromJS(_data["destinationJobTitle"]) : <any>undefined;
            this.destinationPositionId = _data["destinationPositionId"];
            this.destinationPosition = _data["destinationPosition"] ? Position.fromJS(_data["destinationPosition"]) : <any>undefined;
            this.startingDate = _data["startingDate"] ? moment(_data["startingDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["destinationJobTitleId"] = this.destinationJobTitleId;
        data["destinationJobTitle"] = this.destinationJobTitle ? this.destinationJobTitle.toJSON() : <any>undefined;
        data["destinationPositionId"] = this.destinationPositionId;
        data["destinationPosition"] = this.destinationPosition ? this.destinationPosition.toJSON() : <any>undefined;
        data["startingDate"] = this.startingDate ? this.startingDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): Transfer {
        const json = this.toJSON();
        let result = new Transfer();
        result.init(json);
        return result;
    }
}

export interface ITransfer {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    destinationJobTitleId: string;
    destinationJobTitle: JobTitle;
    destinationPositionId: string;
    destinationPosition: Position;
    startingDate: moment.Moment;
    description: string | undefined;
}

export class University implements IUniversity {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;

    constructor(data?: IUniversity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): University {
        data = typeof data === 'object' ? data : {};
        let result = new University();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        return data;
    }

    clone(): University {
        const json = this.toJSON();
        let result = new University();
        result.init(json);
        return result;
    }
}

export interface IUniversity {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
}

export class UniversityDto implements IUniversityDto {
    id: string;
    name: string | undefined;

    constructor(data?: IUniversityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UniversityDto {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): UniversityDto {
        const json = this.toJSON();
        let result = new UniversityDto();
        result.init(json);
        return result;
    }
}

export interface IUniversityDto {
    id: string;
    name: string | undefined;
}

export class UniversityDtoPagedResultDto implements IUniversityDtoPagedResultDto {
    items: UniversityDto[] | undefined;
    totalCount: number;

    constructor(data?: IUniversityDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UniversityDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UniversityDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UniversityDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UniversityDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUniversityDtoPagedResultDto {
    items: UniversityDto[] | undefined;
    totalCount: number;
}

export class UpdateAssignmentDto implements IUpdateAssignmentDto {
    id: string;
    jobTitleId: string;
    positionID: string;
    employeeCardId: string;
    assigningDate: string | undefined;
    description: string | undefined;

    constructor(data?: IUpdateAssignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.positionID = _data["positionID"];
            this.employeeCardId = _data["employeeCardId"];
            this.assigningDate = _data["assigningDate"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateAssignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAssignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["positionID"] = this.positionID;
        data["employeeCardId"] = this.employeeCardId;
        data["assigningDate"] = this.assigningDate;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateAssignmentDto {
        const json = this.toJSON();
        let result = new UpdateAssignmentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAssignmentDto {
    id: string;
    jobTitleId: string;
    positionID: string;
    employeeCardId: string;
    assigningDate: string | undefined;
    description: string | undefined;
}

export class UpdateAttendanceFormDto implements IUpdateAttendanceFormDto {
    id: string;
    name: string | undefined;

    constructor(data?: IUpdateAttendanceFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateAttendanceFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): UpdateAttendanceFormDto {
        const json = this.toJSON();
        let result = new UpdateAttendanceFormDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAttendanceFormDto {
    id: string;
    name: string | undefined;
}

export class UpdateAttendanceMonthlyCardDto implements IUpdateAttendanceMonthlyCardDto {
    id: string;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;

    constructor(data?: IUpdateAttendanceMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCardId = _data["employeeCardId"];
            this.totalRequiredWorkHours = _data["totalRequiredWorkHours"];
            this.actualTotalWorkHours = _data["actualTotalWorkHours"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): UpdateAttendanceMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCardId"] = this.employeeCardId;
        data["totalRequiredWorkHours"] = this.totalRequiredWorkHours;
        data["actualTotalWorkHours"] = this.actualTotalWorkHours;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): UpdateAttendanceMonthlyCardDto {
        const json = this.toJSON();
        let result = new UpdateAttendanceMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAttendanceMonthlyCardDto {
    id: string;
    employeeCardId: string;
    totalRequiredWorkHours: number;
    actualTotalWorkHours: number;
    isCalculated: boolean;
}

export class UpdateAttendanceRecordDto implements IUpdateAttendanceRecordDto {
    id: string;
    year: number;
    month: number;
    name: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    note: string | undefined;
    isCalculated: boolean;

    constructor(data?: IUpdateAttendanceRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.month = _data["month"];
            this.name = _data["name"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.note = _data["note"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): UpdateAttendanceRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAttendanceRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["month"] = this.month;
        data["name"] = this.name;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["note"] = this.note;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): UpdateAttendanceRecordDto {
        const json = this.toJSON();
        let result = new UpdateAttendanceRecordDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateAttendanceRecordDto {
    id: string;
    year: number;
    month: number;
    name: string | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    note: string | undefined;
    isCalculated: boolean;
}

export class UpdateBankDto implements IUpdateBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    phoneNumber: string | undefined;

    constructor(data?: IUpdateBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nationalityId = _data["nationalityId"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nationalityId"] = this.nationalityId;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): UpdateBankDto {
        const json = this.toJSON();
        let result = new UpdateBankDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBankDto {
    id: string;
    name: string | undefined;
    nationalityId: string;
    phoneNumber: string | undefined;
}

export class UpdateBankInformationDto implements IUpdateBankInformationDto {
    id: string;
    bankId: string;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;

    constructor(data?: IUpdateBankInformationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankId = _data["bankId"];
            this.employeeId = _data["employeeId"];
            this.accountNumber = _data["accountNumber"];
            this.accountName = _data["accountName"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateBankInformationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBankInformationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankId"] = this.bankId;
        data["employeeId"] = this.employeeId;
        data["accountNumber"] = this.accountNumber;
        data["accountName"] = this.accountName;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdateBankInformationDto {
        const json = this.toJSON();
        let result = new UpdateBankInformationDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBankInformationDto {
    id: string;
    bankId: string;
    employeeId: string;
    accountNumber: string | undefined;
    accountName: string | undefined;
    fromDate: moment.Moment | undefined;
    toDate: moment.Moment | undefined;
}

export class UpdateBenefitCardDto implements IUpdateBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IUpdateBenefitCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): UpdateBenefitCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBenefitCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): UpdateBenefitCardDto {
        const json = this.toJSON();
        let result = new UpdateBenefitCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateBenefitCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class UpdateCertificateDto implements IUpdateCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;

    constructor(data?: IUpdateCertificateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.cityId = _data["cityId"];
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateCertificateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCertificateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["cityId"] = this.cityId;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): UpdateCertificateDto {
        const json = this.toJSON();
        let result = new UpdateCertificateDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCertificateDto {
    id: string;
    type: string | undefined;
    cityId: string;
    employeeId: string;
    dateofIssuance: moment.Moment;
    expirationDate: moment.Moment;
    notes: string | undefined;
}

export class UpdateChangeableHolidayDto implements IUpdateChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;

    constructor(data?: IUpdateChangeableHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
        }
    }

    static fromJS(data: any): UpdateChangeableHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChangeableHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        return data;
    }

    clone(): UpdateChangeableHolidayDto {
        const json = this.toJSON();
        let result = new UpdateChangeableHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateChangeableHolidayDto {
    id: string;
    name: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
}

export class UpdateChildrenDto implements IUpdateChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;

    constructor(data?: IUpdateChildrenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.spouseId = _data["spouseId"];
            this.employeeId = _data["employeeId"];
            this.orderInFamily = _data["orderInFamily"];
            this.gender = _data["gender"];
            this.maritialStatus = _data["maritialStatus"];
            this.isEmployed = _data["isEmployed"];
            this.isStudying = _data["isStudying"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.disabilityExist = _data["disabilityExist"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.residencyNo = _data["residencyNo"];
            this.residencExpireDate = _data["residencExpireDate"] ? moment(_data["residencExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateChildrenDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChildrenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["spouseId"] = this.spouseId;
        data["employeeId"] = this.employeeId;
        data["orderInFamily"] = this.orderInFamily;
        data["gender"] = this.gender;
        data["maritialStatus"] = this.maritialStatus;
        data["isEmployed"] = this.isEmployed;
        data["isStudying"] = this.isStudying;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["disabilityExist"] = this.disabilityExist;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["residencyNo"] = this.residencyNo;
        data["residencExpireDate"] = this.residencExpireDate ? this.residencExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdateChildrenDto {
        const json = this.toJSON();
        let result = new UpdateChildrenDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateChildrenDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    spouseId: string;
    employeeId: string;
    orderInFamily: number;
    gender: number;
    maritialStatus: number;
    isEmployed: boolean;
    isStudying: boolean;
    dateofBirth: moment.Moment;
    disabilityExist: boolean;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencExpireDate: moment.Moment | undefined;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
}

export class UpdateCompanyHolidayDto implements IUpdateCompanyHolidayDto {
    id: string;
    dayOfWeek: number;

    constructor(data?: IUpdateCompanyHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dayOfWeek = _data["dayOfWeek"];
        }
    }

    static fromJS(data: any): UpdateCompanyHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dayOfWeek"] = this.dayOfWeek;
        return data;
    }

    clone(): UpdateCompanyHolidayDto {
        const json = this.toJSON();
        let result = new UpdateCompanyHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyHolidayDto {
    id: string;
    dayOfWeek: number;
}

export class UpdateConvictionDto implements IUpdateConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;

    constructor(data?: IUpdateConvictionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.isConvicted = _data["isConvicted"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateConvictionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConvictionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["isConvicted"] = this.isConvicted;
        data["notes"] = this.notes;
        return data;
    }

    clone(): UpdateConvictionDto {
        const json = this.toJSON();
        let result = new UpdateConvictionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateConvictionDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    releaseDate: moment.Moment | undefined;
    expiryDate: moment.Moment | undefined;
    isConvicted: boolean;
    notes: string | undefined;
}

export class UpdateCustodieDto implements IUpdateCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: IUpdateCustodieDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateCustodieDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustodieDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): UpdateCustodieDto {
        const json = this.toJSON();
        let result = new UpdateCustodieDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCustodieDto {
    id: string;
    employeeId: string;
    name: string | undefined;
    quantity: number;
    startDate: moment.Moment;
    endDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class UpdateDeductionCardDto implements IUpdateDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;

    constructor(data?: IUpdateDeductionCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.formula = _data["formula"];
        }
    }

    static fromJS(data: any): UpdateDeductionCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeductionCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["value"] = this.value;
        data["formula"] = this.formula;
        return data;
    }

    clone(): UpdateDeductionCardDto {
        const json = this.toJSON();
        let result = new UpdateDeductionCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDeductionCardDto {
    id: string;
    name: string | undefined;
    value: number;
    formula: Formula;
}

export class UpdateDependentDto implements IUpdateDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;

    constructor(data?: IUpdateDependentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.kinshipLevel = _data["kinshipLevel"];
            this.kinshipTypeId = _data["kinshipTypeId"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.contactNumber = _data["contactNumber"];
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateDependentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDependentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["kinshipLevel"] = this.kinshipLevel;
        data["kinshipTypeId"] = this.kinshipTypeId;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["contactNumber"] = this.contactNumber;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdateDependentDto {
        const json = this.toJSON();
        let result = new UpdateDependentDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDependentDto {
    id: string;
    employeeId: string;
    firstName: string | undefined;
    lastName: string | undefined;
    kinshipLevel: KinshipLevel;
    kinshipTypeId: string;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    contactNumber: string | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
}

export class UpdateDriverLicenseDto implements IUpdateDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    placeofIssuanceId: string;

    constructor(data?: IUpdateDriverLicenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.legalCondition = _data["legalCondition"];
            this.driverLicenseTypeId = _data["driverLicenseTypeId"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
        }
    }

    static fromJS(data: any): UpdateDriverLicenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDriverLicenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["legalCondition"] = this.legalCondition;
        data["driverLicenseTypeId"] = this.driverLicenseTypeId;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        return data;
    }

    clone(): UpdateDriverLicenseDto {
        const json = this.toJSON();
        let result = new UpdateDriverLicenseDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateDriverLicenseDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    issuanceDate: moment.Moment;
    expiryDate: moment.Moment;
    legalCondition: string | undefined;
    driverLicenseTypeId: string;
    placeofIssuanceId: string;
}

export class UpdateEducationDto implements IUpdateEducationDto {
    id: string;
    typeId: string;
    majorId: string;
    universityId: string;
    rankId: string;
    scoreTypeId: string;
    scoreId: string;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;

    constructor(data?: IUpdateEducationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.typeId = _data["typeId"];
            this.majorId = _data["majorId"];
            this.universityId = _data["universityId"];
            this.rankId = _data["rankId"];
            this.scoreTypeId = _data["scoreTypeId"];
            this.scoreId = _data["scoreId"];
            this.employeeId = _data["employeeId"];
            this.dateofIssuance = _data["dateofIssuance"] ? moment(_data["dateofIssuance"].toString()) : <any>undefined;
            this.countryId = _data["countryId"];
            this.amendmentDocumentNo = _data["amendmentDocumentNo"];
            this.amendmentDocumentDate = _data["amendmentDocumentDate"] ? moment(_data["amendmentDocumentDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): UpdateEducationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEducationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["typeId"] = this.typeId;
        data["majorId"] = this.majorId;
        data["universityId"] = this.universityId;
        data["rankId"] = this.rankId;
        data["scoreTypeId"] = this.scoreTypeId;
        data["scoreId"] = this.scoreId;
        data["employeeId"] = this.employeeId;
        data["dateofIssuance"] = this.dateofIssuance ? this.dateofIssuance.toISOString() : <any>undefined;
        data["countryId"] = this.countryId;
        data["amendmentDocumentNo"] = this.amendmentDocumentNo;
        data["amendmentDocumentDate"] = this.amendmentDocumentDate ? this.amendmentDocumentDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        return data;
    }

    clone(): UpdateEducationDto {
        const json = this.toJSON();
        let result = new UpdateEducationDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEducationDto {
    id: string;
    typeId: string;
    majorId: string;
    universityId: string;
    rankId: string;
    scoreTypeId: string;
    scoreId: string;
    employeeId: string;
    dateofIssuance: moment.Moment | undefined;
    countryId: string;
    amendmentDocumentNo: string | undefined;
    amendmentDocumentDate: moment.Moment | undefined;
    comments: string | undefined;
}

export class UpdateEducationGradeDto implements IUpdateEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;

    constructor(data?: IUpdateEducationGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateEducationGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEducationGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateEducationGradeDto {
        const json = this.toJSON();
        let result = new UpdateEducationGradeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEducationGradeDto {
    id: string;
    name: string | undefined;
    order: number;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    description: string | undefined;
}

export class UpdateEmployeeCardDto implements IUpdateEmployeeCardDto {
    id: string;
    employeeId: string;
    jobDescriptionId: string | undefined;
    positionId: string | undefined;
    jobTitleId: string | undefined;
    gradeId: string | undefined;
    attendanceFormId: string | undefined;
    startWorkingDate: string | undefined;
    endWorkingDate: string | undefined;
    probationPeriodDate: string | undefined;
    contractType: number;

    constructor(data?: IUpdateEmployeeCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.positionId = _data["positionId"];
            this.jobTitleId = _data["jobTitleId"];
            this.gradeId = _data["gradeId"];
            this.attendanceFormId = _data["attendanceFormId"];
            this.startWorkingDate = _data["startWorkingDate"];
            this.endWorkingDate = _data["endWorkingDate"];
            this.probationPeriodDate = _data["probationPeriodDate"];
            this.contractType = _data["contractType"];
        }
    }

    static fromJS(data: any): UpdateEmployeeCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmployeeCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["positionId"] = this.positionId;
        data["jobTitleId"] = this.jobTitleId;
        data["gradeId"] = this.gradeId;
        data["attendanceFormId"] = this.attendanceFormId;
        data["startWorkingDate"] = this.startWorkingDate;
        data["endWorkingDate"] = this.endWorkingDate;
        data["probationPeriodDate"] = this.probationPeriodDate;
        data["contractType"] = this.contractType;
        return data;
    }

    clone(): UpdateEmployeeCardDto {
        const json = this.toJSON();
        let result = new UpdateEmployeeCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEmployeeCardDto {
    id: string;
    employeeId: string;
    jobDescriptionId: string | undefined;
    positionId: string | undefined;
    jobTitleId: string | undefined;
    gradeId: string | undefined;
    attendanceFormId: string | undefined;
    startWorkingDate: string | undefined;
    endWorkingDate: string | undefined;
    probationPeriodDate: string | undefined;
    contractType: number;
}

export class UpdateEmployeeDto implements IUpdateEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    readonly fullName: string | undefined;
    readonly tripleName: string | undefined;
    placeofBirthId: string;
    dateofBirth: string | undefined;
    readonly age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    readonly fullNameAr: string | undefined;
    readonly tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    secondaryNationalityId: string;
    maritialStatus: number;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    bloodType: number;
    userId: number;

    constructor(data?: IUpdateEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            (<any>this).fullName = _data["fullName"];
            (<any>this).tripleName = _data["tripleName"];
            this.placeofBirthId = _data["placeofBirthId"];
            this.dateofBirth = _data["dateofBirth"];
            (<any>this).age = _data["age"];
            this.idNumber = _data["idNumber"];
            this.countryofBirthId = _data["countryofBirthId"];
            this.personalRecordSource = _data["personalRecordSource"];
            this.civilRecordPlaceAndNumber = _data["civilRecordPlaceAndNumber"];
            this.gender = _data["gender"];
            this.religionId = _data["religionId"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherNameAr = _data["fatherNameAr"];
            this.motherNameAr = _data["motherNameAr"];
            (<any>this).fullNameAr = _data["fullNameAr"];
            (<any>this).tripleNameAr = _data["tripleNameAr"];
            this.placeofBirthAr = _data["placeofBirthAr"];
            this.nationalityId = _data["nationalityId"];
            this.secondaryNationalityId = _data["secondaryNationalityId"];
            this.maritialStatus = _data["maritialStatus"];
            this.photoPath = _data["photoPath"];
            this.address = _data["address"];
            this.mobile = _data["mobile"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.webSite = _data["webSite"];
            this.facebook = _data["facebook"];
            this.bloodType = _data["bloodType"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UpdateEmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["fullName"] = this.fullName;
        data["tripleName"] = this.tripleName;
        data["placeofBirthId"] = this.placeofBirthId;
        data["dateofBirth"] = this.dateofBirth;
        data["age"] = this.age;
        data["idNumber"] = this.idNumber;
        data["countryofBirthId"] = this.countryofBirthId;
        data["personalRecordSource"] = this.personalRecordSource;
        data["civilRecordPlaceAndNumber"] = this.civilRecordPlaceAndNumber;
        data["gender"] = this.gender;
        data["religionId"] = this.religionId;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherNameAr"] = this.fatherNameAr;
        data["motherNameAr"] = this.motherNameAr;
        data["fullNameAr"] = this.fullNameAr;
        data["tripleNameAr"] = this.tripleNameAr;
        data["placeofBirthAr"] = this.placeofBirthAr;
        data["nationalityId"] = this.nationalityId;
        data["secondaryNationalityId"] = this.secondaryNationalityId;
        data["maritialStatus"] = this.maritialStatus;
        data["photoPath"] = this.photoPath;
        data["address"] = this.address;
        data["mobile"] = this.mobile;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["webSite"] = this.webSite;
        data["facebook"] = this.facebook;
        data["bloodType"] = this.bloodType;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UpdateEmployeeDto {
        const json = this.toJSON();
        let result = new UpdateEmployeeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEmployeeDto {
    id: string;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    fullName: string | undefined;
    tripleName: string | undefined;
    placeofBirthId: string;
    dateofBirth: string | undefined;
    age: number;
    idNumber: string | undefined;
    countryofBirthId: string;
    personalRecordSource: string | undefined;
    civilRecordPlaceAndNumber: string | undefined;
    gender: number;
    religionId: string;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherNameAr: string | undefined;
    motherNameAr: string | undefined;
    fullNameAr: string | undefined;
    tripleNameAr: string | undefined;
    placeofBirthAr: string | undefined;
    nationalityId: string;
    secondaryNationalityId: string;
    maritialStatus: number;
    photoPath: string | undefined;
    address: string | undefined;
    mobile: string | undefined;
    phone: string | undefined;
    email: string | undefined;
    webSite: string | undefined;
    facebook: string | undefined;
    bloodType: number;
    userId: number;
}

export class UpdateEntranceExitRecordDto implements IUpdateEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    employeeId: string;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;

    constructor(data?: IUpdateEntranceExitRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.logDate = _data["logDate"];
            this.employeeId = _data["employeeId"];
            this.logTime = _data["logTime"];
            this.recordType = _data["recordType"];
            this.notes = _data["notes"];
            this.isChecked = _data["isChecked"];
        }
    }

    static fromJS(data: any): UpdateEntranceExitRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntranceExitRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["logDate"] = this.logDate;
        data["employeeId"] = this.employeeId;
        data["logTime"] = this.logTime;
        data["recordType"] = this.recordType;
        data["notes"] = this.notes;
        data["isChecked"] = this.isChecked;
        return data;
    }

    clone(): UpdateEntranceExitRecordDto {
        const json = this.toJSON();
        let result = new UpdateEntranceExitRecordDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateEntranceExitRecordDto {
    id: string;
    logDate: string | undefined;
    employeeId: string;
    logTime: string | undefined;
    recordType: number;
    notes: string | undefined;
    isChecked: boolean;
}

export class UpdateExperienceDto implements IUpdateExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;

    constructor(data?: IUpdateExperienceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.jobTitle = _data["jobTitle"];
            this.industry = _data["industry"];
            this.companyName = _data["companyName"];
            this.companyLocation = _data["companyLocation"];
            this.companyWebSite = _data["companyWebSite"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.leaveReason = _data["leaveReason"];
            this.notes = _data["notes"];
            this.referenceFullName = _data["referenceFullName"];
            this.referenceJobTitle = _data["referenceJobTitle"];
            this.referenceContact = _data["referenceContact"];
            this.referenceEmail = _data["referenceEmail"];
        }
    }

    static fromJS(data: any): UpdateExperienceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExperienceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["jobTitle"] = this.jobTitle;
        data["industry"] = this.industry;
        data["companyName"] = this.companyName;
        data["companyLocation"] = this.companyLocation;
        data["companyWebSite"] = this.companyWebSite;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["leaveReason"] = this.leaveReason;
        data["notes"] = this.notes;
        data["referenceFullName"] = this.referenceFullName;
        data["referenceJobTitle"] = this.referenceJobTitle;
        data["referenceContact"] = this.referenceContact;
        data["referenceEmail"] = this.referenceEmail;
        return data;
    }

    clone(): UpdateExperienceDto {
        const json = this.toJSON();
        let result = new UpdateExperienceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateExperienceDto {
    id: string;
    employeeId: string;
    jobTitle: string | undefined;
    industry: string | undefined;
    companyName: string | undefined;
    companyLocation: string | undefined;
    companyWebSite: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    leaveReason: string | undefined;
    notes: string | undefined;
    referenceFullName: string | undefined;
    referenceJobTitle: string | undefined;
    referenceContact: string | undefined;
    referenceEmail: string | undefined;
}

export class UpdateFinancialCardDto implements IUpdateFinancialCardDto {
    id: string;
    employeeId: string;
    salary: number;

    constructor(data?: IUpdateFinancialCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.salary = _data["salary"];
        }
    }

    static fromJS(data: any): UpdateFinancialCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFinancialCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["salary"] = this.salary;
        return data;
    }

    clone(): UpdateFinancialCardDto {
        const json = this.toJSON();
        let result = new UpdateFinancialCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFinancialCardDto {
    id: string;
    employeeId: string;
    salary: number;
}

export class UpdateFixedHolidayDto implements IUpdateFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;

    constructor(data?: IUpdateFixedHolidayDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.day = _data["day"];
            this.month = _data["month"];
            this.numberofDays = _data["numberofDays"];
        }
    }

    static fromJS(data: any): UpdateFixedHolidayDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFixedHolidayDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["day"] = this.day;
        data["month"] = this.month;
        data["numberofDays"] = this.numberofDays;
        return data;
    }

    clone(): UpdateFixedHolidayDto {
        const json = this.toJSON();
        let result = new UpdateFixedHolidayDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateFixedHolidayDto {
    id: string;
    name: string | undefined;
    day: string | undefined;
    month: string | undefined;
    numberofDays: number;
}

export class UpdateGradeDto implements IUpdateGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    educationGradeId: string;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;

    constructor(data?: IUpdateGradeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationLevelId = _data["organizationLevelId"];
            this.educationGradeId = _data["educationGradeId"];
            this.minSalary = _data["minSalary"];
            this.maxSalary = _data["maxSalary"];
            this.currency = _data["currency"];
            this.gradeCategory = _data["gradeCategory"];
        }
    }

    static fromJS(data: any): UpdateGradeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGradeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationLevelId"] = this.organizationLevelId;
        data["educationGradeId"] = this.educationGradeId;
        data["minSalary"] = this.minSalary;
        data["maxSalary"] = this.maxSalary;
        data["currency"] = this.currency;
        data["gradeCategory"] = this.gradeCategory;
        return data;
    }

    clone(): UpdateGradeDto {
        const json = this.toJSON();
        let result = new UpdateGradeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateGradeDto {
    id: string;
    name: string | undefined;
    organizationLevelId: string;
    educationGradeId: string;
    minSalary: number | undefined;
    maxSalary: number | undefined;
    currency: number | undefined;
    gradeCategory: number;
}

export class UpdateHourlyMissionDto implements IUpdateHourlyMissionDto {
    id: string;
    employeeId: string;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IUpdateHourlyMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? moment(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? moment(_data["endTime"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateHourlyMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHourlyMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): UpdateHourlyMissionDto {
        const json = this.toJSON();
        let result = new UpdateHourlyMissionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateHourlyMissionDto {
    id: string;
    employeeId: string;
    date: moment.Moment;
    startTime: moment.Moment;
    endTime: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class UpdateJobDescriptionDto implements IUpdateJobDescriptionDto {
    id: string;
    jobTitleId: string;
    name: string | undefined;
    nodeId: string;
    description: string | undefined;

    constructor(data?: IUpdateJobDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.name = _data["name"];
            this.nodeId = _data["nodeId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateJobDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["name"] = this.name;
        data["nodeId"] = this.nodeId;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateJobDescriptionDto {
        const json = this.toJSON();
        let result = new UpdateJobDescriptionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateJobDescriptionDto {
    id: string;
    jobTitleId: string;
    name: string | undefined;
    nodeId: string;
    description: string | undefined;
}

export class UpdateJobTitleDto implements IUpdateJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;

    constructor(data?: IUpdateJobTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.employeeCount = _data["employeeCount"];
            this.description = _data["description"];
            this.gradeId = _data["gradeId"];
        }
    }

    static fromJS(data: any): UpdateJobTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["employeeCount"] = this.employeeCount;
        data["description"] = this.description;
        data["gradeId"] = this.gradeId;
        return data;
    }

    clone(): UpdateJobTitleDto {
        const json = this.toJSON();
        let result = new UpdateJobTitleDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateJobTitleDto {
    id: string;
    name: string | undefined;
    order: number;
    employeeCount: number;
    description: string | undefined;
    gradeId: string;
}

export class UpdateLanguageDto implements IUpdateLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    writingId: string;
    readingId: string;
    speakingId: string;
    listeningId: string;

    constructor(data?: IUpdateLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.languageNameId = _data["languageNameId"];
            this.writingId = _data["writingId"];
            this.readingId = _data["readingId"];
            this.speakingId = _data["speakingId"];
            this.listeningId = _data["listeningId"];
        }
    }

    static fromJS(data: any): UpdateLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["languageNameId"] = this.languageNameId;
        data["writingId"] = this.writingId;
        data["readingId"] = this.readingId;
        data["speakingId"] = this.speakingId;
        data["listeningId"] = this.listeningId;
        return data;
    }

    clone(): UpdateLanguageDto {
        const json = this.toJSON();
        let result = new UpdateLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguageDto {
    id: string;
    employeeId: string;
    languageNameId: string;
    writingId: string;
    readingId: string;
    speakingId: string;
    listeningId: string;
}

export class UpdateLeaveRequestDto implements IUpdateLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    employeeId: string;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    readonly leaveRequestBalance: number;
    description: string | undefined;

    constructor(data?: IUpdateLeaveRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.leaveSettingId = _data["leaveSettingId"];
            this.employeeId = _data["employeeId"];
            this.requestDate = _data["requestDate"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.isHourly = _data["isHourly"];
            this.startHour = _data["startHour"];
            this.endHour = _data["endHour"];
            (<any>this).leaveRequestBalance = _data["leaveRequestBalance"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLeaveRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeaveRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["leaveSettingId"] = this.leaveSettingId;
        data["employeeId"] = this.employeeId;
        data["requestDate"] = this.requestDate;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["isHourly"] = this.isHourly;
        data["startHour"] = this.startHour;
        data["endHour"] = this.endHour;
        data["leaveRequestBalance"] = this.leaveRequestBalance;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateLeaveRequestDto {
        const json = this.toJSON();
        let result = new UpdateLeaveRequestDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateLeaveRequestDto {
    id: string;
    leaveSettingId: string;
    employeeId: string;
    requestDate: string | undefined;
    startDate: string | undefined;
    endDate: string | undefined;
    isHourly: boolean;
    startHour: string | undefined;
    endHour: string | undefined;
    leaveRequestBalance: number;
    description: string | undefined;
}

export class UpdateLeaveSettingDto implements IUpdateLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    description: string | undefined;

    constructor(data?: IUpdateLeaveSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.balance = _data["balance"];
            this.isPaidLeave = _data["isPaidLeave"];
            this.workflowSettingId = _data["workflowSettingId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateLeaveSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeaveSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["balance"] = this.balance;
        data["isPaidLeave"] = this.isPaidLeave;
        data["workflowSettingId"] = this.workflowSettingId;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateLeaveSettingDto {
        const json = this.toJSON();
        let result = new UpdateLeaveSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateLeaveSettingDto {
    id: string;
    name: string | undefined;
    balance: number;
    isPaidLeave: boolean;
    workflowSettingId: string;
    description: string | undefined;
}

export class UpdateMilitaryServiceDto implements IUpdateMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;

    constructor(data?: IUpdateMilitaryServiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.militaryStatus = _data["militaryStatus"];
            this.isPermanentExemption = _data["isPermanentExemption"];
            this.exemptionReason = _data["exemptionReason"];
            this.exemptionDate = _data["exemptionDate"] ? moment(_data["exemptionDate"].toString()) : <any>undefined;
            this.delayReason = _data["delayReason"];
            this.delayDate = _data["delayDate"] ? moment(_data["delayDate"].toString()) : <any>undefined;
            this.militaryServiceNo = _data["militaryServiceNo"];
            this.militaryServiceDocIssueDate = _data["militaryServiceDocIssueDate"] ? moment(_data["militaryServiceDocIssueDate"].toString()) : <any>undefined;
            this.granter = _data["granter"];
            this.years = _data["years"];
            this.months = _data["months"];
            this.days = _data["days"];
            this.serviceStartDate = _data["serviceStartDate"] ? moment(_data["serviceStartDate"].toString()) : <any>undefined;
            this.serviceEndDate = _data["serviceEndDate"] ? moment(_data["serviceEndDate"].toString()) : <any>undefined;
            this.holdDate = _data["holdDate"] ? moment(_data["holdDate"].toString()) : <any>undefined;
            this.reserveStartDate = _data["reserveStartDate"] ? moment(_data["reserveStartDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateMilitaryServiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMilitaryServiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["militaryStatus"] = this.militaryStatus;
        data["isPermanentExemption"] = this.isPermanentExemption;
        data["exemptionReason"] = this.exemptionReason;
        data["exemptionDate"] = this.exemptionDate ? this.exemptionDate.toISOString() : <any>undefined;
        data["delayReason"] = this.delayReason;
        data["delayDate"] = this.delayDate ? this.delayDate.toISOString() : <any>undefined;
        data["militaryServiceNo"] = this.militaryServiceNo;
        data["militaryServiceDocIssueDate"] = this.militaryServiceDocIssueDate ? this.militaryServiceDocIssueDate.toISOString() : <any>undefined;
        data["granter"] = this.granter;
        data["years"] = this.years;
        data["months"] = this.months;
        data["days"] = this.days;
        data["serviceStartDate"] = this.serviceStartDate ? this.serviceStartDate.toISOString() : <any>undefined;
        data["serviceEndDate"] = this.serviceEndDate ? this.serviceEndDate.toISOString() : <any>undefined;
        data["holdDate"] = this.holdDate ? this.holdDate.toISOString() : <any>undefined;
        data["reserveStartDate"] = this.reserveStartDate ? this.reserveStartDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        return data;
    }

    clone(): UpdateMilitaryServiceDto {
        const json = this.toJSON();
        let result = new UpdateMilitaryServiceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMilitaryServiceDto {
    id: string;
    employeeId: string;
    militaryStatus: MilitaryStatus;
    isPermanentExemption: boolean | undefined;
    exemptionReason: string | undefined;
    exemptionDate: moment.Moment | undefined;
    delayReason: string | undefined;
    delayDate: moment.Moment | undefined;
    militaryServiceNo: string | undefined;
    militaryServiceDocIssueDate: moment.Moment | undefined;
    granter: string | undefined;
    years: number | undefined;
    months: number | undefined;
    days: number | undefined;
    serviceStartDate: moment.Moment | undefined;
    serviceEndDate: moment.Moment | undefined;
    holdDate: moment.Moment | undefined;
    reserveStartDate: moment.Moment | undefined;
    notes: string | undefined;
}

export class UpdateMonthDto implements IUpdateMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;

    constructor(data?: IUpdateMonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.year = _data["year"];
            this.monthName = _data["monthName"];
            this.title = _data["title"];
            this.isCalculated = _data["isCalculated"];
        }
    }

    static fromJS(data: any): UpdateMonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["monthName"] = this.monthName;
        data["title"] = this.title;
        data["isCalculated"] = this.isCalculated;
        return data;
    }

    clone(): UpdateMonthDto {
        const json = this.toJSON();
        let result = new UpdateMonthDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMonthDto {
    id: string;
    year: number;
    monthName: number;
    title: string | undefined;
    isCalculated: boolean;
}

export class UpdateMonthlyCardDto implements IUpdateMonthlyCardDto {
    id: string;
    employeeCardId: string;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;

    constructor(data?: IUpdateMonthlyCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeCardId = _data["employeeCardId"];
            this.salary = _data["salary"];
            this.calculated = _data["calculated"];
            this.workDays = _data["workDays"];
            this.totalDeductions = _data["totalDeductions"];
            this.totalBenefits = _data["totalBenefits"];
            this.finalSalary = _data["finalSalary"];
        }
    }

    static fromJS(data: any): UpdateMonthlyCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMonthlyCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeCardId"] = this.employeeCardId;
        data["salary"] = this.salary;
        data["calculated"] = this.calculated;
        data["workDays"] = this.workDays;
        data["totalDeductions"] = this.totalDeductions;
        data["totalBenefits"] = this.totalBenefits;
        data["finalSalary"] = this.finalSalary;
        return data;
    }

    clone(): UpdateMonthlyCardDto {
        const json = this.toJSON();
        let result = new UpdateMonthlyCardDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateMonthlyCardDto {
    id: string;
    employeeCardId: string;
    salary: number;
    calculated: boolean;
    workDays: number;
    totalDeductions: number;
    totalBenefits: number;
    finalSalary: number;
}

export class UpdateNodeDto implements IUpdateNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    code: string | undefined;
    isRoot: boolean;

    constructor(data?: IUpdateNodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.isRoot = _data["isRoot"];
        }
    }

    static fromJS(data: any): UpdateNodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["isRoot"] = this.isRoot;
        return data;
    }

    clone(): UpdateNodeDto {
        const json = this.toJSON();
        let result = new UpdateNodeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateNodeDto {
    id: string;
    name: string | undefined;
    type: number;
    parentId: string | undefined;
    code: string | undefined;
    isRoot: boolean;
}

export class UpdateNormalShiftDto implements IUpdateNormalShiftDto {
    id: string;
    workshopId: string;
    entryTime: string | undefined;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;

    constructor(data?: IUpdateNormalShiftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workshopId = _data["workshopId"];
            this.entryTime = _data["entryTime"];
            this.exitTime = _data["exitTime"];
            this.shiftRangeStartTime = _data["shiftRangeStartTime"];
            this.shiftRangeEndTime = _data["shiftRangeEndTime"];
        }
    }

    static fromJS(data: any): UpdateNormalShiftDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNormalShiftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workshopId"] = this.workshopId;
        data["entryTime"] = this.entryTime;
        data["exitTime"] = this.exitTime;
        data["shiftRangeStartTime"] = this.shiftRangeStartTime;
        data["shiftRangeEndTime"] = this.shiftRangeEndTime;
        return data;
    }

    clone(): UpdateNormalShiftDto {
        const json = this.toJSON();
        let result = new UpdateNormalShiftDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateNormalShiftDto {
    id: string;
    workshopId: string;
    entryTime: string | undefined;
    exitTime: string | undefined;
    shiftRangeStartTime: string | undefined;
    shiftRangeEndTime: string | undefined;
}

export class UpdateOrganizationLevelDto implements IUpdateOrganizationLevelDto {
    id: string;
    name: string | undefined;

    constructor(data?: IUpdateOrganizationLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateOrganizationLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): UpdateOrganizationLevelDto {
        const json = this.toJSON();
        let result = new UpdateOrganizationLevelDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationLevelDto {
    id: string;
    name: string | undefined;
}

export class UpdatePassportDto implements IUpdatePassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;

    constructor(data?: IUpdatePassportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.firstNameAr = _data["firstNameAr"];
            this.lastNameAr = _data["lastNameAr"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.placeofIssuanceId = _data["placeofIssuanceId"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePassportDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePassportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["firstNameAr"] = this.firstNameAr;
        data["lastNameAr"] = this.lastNameAr;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["placeofIssuanceId"] = this.placeofIssuanceId;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UpdatePassportDto {
        const json = this.toJSON();
        let result = new UpdatePassportDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePassportDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    firstNameAr: string | undefined;
    lastNameAr: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    placeofIssuanceId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
}

export class UpdatePositionDto implements IUpdatePositionDto {
    id: string;
    jobDescriptionId: string;
    positionWorkTypeId: string;
    workingHours: number;
    per: number;
    hasManager: boolean;
    managerId: string | undefined;

    constructor(data?: IUpdatePositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobDescriptionId = _data["jobDescriptionId"];
            this.positionWorkTypeId = _data["positionWorkTypeId"];
            this.workingHours = _data["workingHours"];
            this.per = _data["per"];
            this.hasManager = _data["hasManager"];
            this.managerId = _data["managerId"];
        }
    }

    static fromJS(data: any): UpdatePositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobDescriptionId"] = this.jobDescriptionId;
        data["positionWorkTypeId"] = this.positionWorkTypeId;
        data["workingHours"] = this.workingHours;
        data["per"] = this.per;
        data["hasManager"] = this.hasManager;
        data["managerId"] = this.managerId;
        return data;
    }

    clone(): UpdatePositionDto {
        const json = this.toJSON();
        let result = new UpdatePositionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionDto {
    id: string;
    jobDescriptionId: string;
    positionWorkTypeId: string;
    workingHours: number;
    per: number;
    hasManager: boolean;
    managerId: string | undefined;
}

export class UpdatePositionWorkTypeDto implements IUpdatePositionWorkTypeDto {
    id: string;
    name: string | undefined;

    constructor(data?: IUpdatePositionWorkTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdatePositionWorkTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionWorkTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): UpdatePositionWorkTypeDto {
        const json = this.toJSON();
        let result = new UpdatePositionWorkTypeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionWorkTypeDto {
    id: string;
    name: string | undefined;
}

export class UpdatePromotionDto implements IUpdatePromotionDto {
    id: string;
    jobTitleId: string;
    positionId: string;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IUpdatePromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jobTitleId = _data["jobTitleId"];
            this.positionId = _data["positionId"];
            this.employeeCardId = _data["employeeCardId"];
            this.promotionDate = _data["promotionDate"] ? moment(_data["promotionDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdatePromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jobTitleId"] = this.jobTitleId;
        data["positionId"] = this.positionId;
        data["employeeCardId"] = this.employeeCardId;
        data["promotionDate"] = this.promotionDate ? this.promotionDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdatePromotionDto {
        const json = this.toJSON();
        let result = new UpdatePromotionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdatePromotionDto {
    id: string;
    jobTitleId: string;
    positionId: string;
    employeeCardId: string;
    promotionDate: moment.Moment;
    description: string | undefined;
}

export class UpdateResidencyDto implements IUpdateResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;

    constructor(data?: IUpdateResidencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.number = _data["number"];
            this.firstName = _data["firstName"];
            this.secondName = _data["secondName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.residencyType = _data["residencyType"];
            this.nationalityId = _data["nationalityId"];
            this.issuanceDate = _data["issuanceDate"] ? moment(_data["issuanceDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? moment(_data["expirationDate"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.tel = _data["tel"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateResidencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResidencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["number"] = this.number;
        data["firstName"] = this.firstName;
        data["secondName"] = this.secondName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["residencyType"] = this.residencyType;
        data["nationalityId"] = this.nationalityId;
        data["issuanceDate"] = this.issuanceDate ? this.issuanceDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["tel"] = this.tel;
        data["notes"] = this.notes;
        return data;
    }

    clone(): UpdateResidencyDto {
        const json = this.toJSON();
        let result = new UpdateResidencyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateResidencyDto {
    id: string;
    employeeId: string;
    number: string | undefined;
    firstName: string | undefined;
    secondName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    residencyType: ResidencyType;
    nationalityId: string;
    issuanceDate: moment.Moment;
    expirationDate: moment.Moment;
    address: string | undefined;
    tel: string | undefined;
    notes: string | undefined;
}

export class UpdateResignationDto implements IUpdateResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    description: string | undefined;

    constructor(data?: IUpdateResignationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resignationDate = _data["resignationDate"] ? moment(_data["resignationDate"].toString()) : <any>undefined;
            this.employeeCardId = _data["employeeCardId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateResignationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResignationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resignationDate"] = this.resignationDate ? this.resignationDate.toISOString() : <any>undefined;
        data["employeeCardId"] = this.employeeCardId;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateResignationDto {
        const json = this.toJSON();
        let result = new UpdateResignationDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateResignationDto {
    id: string;
    resignationDate: moment.Moment;
    employeeCardId: string;
    description: string | undefined;
}

export class UpdateSkillDto implements IUpdateSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    description: string | undefined;
    comments: string | undefined;

    constructor(data?: IUpdateSkillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.skillName = _data["skillName"];
            this.levelId = _data["levelId"];
            this.description = _data["description"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): UpdateSkillDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSkillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["skillName"] = this.skillName;
        data["levelId"] = this.levelId;
        data["description"] = this.description;
        data["comments"] = this.comments;
        return data;
    }

    clone(): UpdateSkillDto {
        const json = this.toJSON();
        let result = new UpdateSkillDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSkillDto {
    id: string;
    employeeId: string;
    skillName: string | undefined;
    levelId: string;
    description: string | undefined;
    comments: string | undefined;
}

export class UpdateSpouseDto implements IUpdateSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;

    constructor(data?: IUpdateSpouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.idNumber = _data["idNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fatherName = _data["fatherName"];
            this.motherName = _data["motherName"];
            this.dateofBirth = _data["dateofBirth"] ? moment(_data["dateofBirth"].toString()) : <any>undefined;
            this.placeofBirthId = _data["placeofBirthId"];
            this.nationalityId = _data["nationalityId"];
            this.residencyNo = _data["residencyNo"];
            this.residencyExpireDate = _data["residencyExpireDate"] ? moment(_data["residencyExpireDate"].toString()) : <any>undefined;
            this.passportNo = _data["passportNo"];
            this.passportExpireDate = _data["passportExpireDate"] ? moment(_data["passportExpireDate"].toString()) : <any>undefined;
            this.firstContactNumber = _data["firstContactNumber"];
            this.secondContactNumber = _data["secondContactNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.gender = _data["gender"];
            this.order = _data["order"];
            this.marrigeDate = _data["marrigeDate"] ? moment(_data["marrigeDate"].toString()) : <any>undefined;
            this.isDivorced = _data["isDivorced"];
            this.divorceDate = _data["divorceDate"] ? moment(_data["divorceDate"].toString()) : <any>undefined;
            this.isDead = _data["isDead"];
            this.deathDate = _data["deathDate"] ? moment(_data["deathDate"].toString()) : <any>undefined;
            this.hasJob = _data["hasJob"];
            this.jobTitle = _data["jobTitle"];
            this.companyName = _data["companyName"];
            this.workAddress = _data["workAddress"];
            this.workPhone = _data["workPhone"];
            this.workEmail = _data["workEmail"];
        }
    }

    static fromJS(data: any): UpdateSpouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSpouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["idNumber"] = this.idNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fatherName"] = this.fatherName;
        data["motherName"] = this.motherName;
        data["dateofBirth"] = this.dateofBirth ? this.dateofBirth.toISOString() : <any>undefined;
        data["placeofBirthId"] = this.placeofBirthId;
        data["nationalityId"] = this.nationalityId;
        data["residencyNo"] = this.residencyNo;
        data["residencyExpireDate"] = this.residencyExpireDate ? this.residencyExpireDate.toISOString() : <any>undefined;
        data["passportNo"] = this.passportNo;
        data["passportExpireDate"] = this.passportExpireDate ? this.passportExpireDate.toISOString() : <any>undefined;
        data["firstContactNumber"] = this.firstContactNumber;
        data["secondContactNumber"] = this.secondContactNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["gender"] = this.gender;
        data["order"] = this.order;
        data["marrigeDate"] = this.marrigeDate ? this.marrigeDate.toISOString() : <any>undefined;
        data["isDivorced"] = this.isDivorced;
        data["divorceDate"] = this.divorceDate ? this.divorceDate.toISOString() : <any>undefined;
        data["isDead"] = this.isDead;
        data["deathDate"] = this.deathDate ? this.deathDate.toISOString() : <any>undefined;
        data["hasJob"] = this.hasJob;
        data["jobTitle"] = this.jobTitle;
        data["companyName"] = this.companyName;
        data["workAddress"] = this.workAddress;
        data["workPhone"] = this.workPhone;
        data["workEmail"] = this.workEmail;
        return data;
    }

    clone(): UpdateSpouseDto {
        const json = this.toJSON();
        let result = new UpdateSpouseDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateSpouseDto {
    id: string;
    employeeId: string;
    idNumber: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    fatherName: string | undefined;
    motherName: string | undefined;
    dateofBirth: moment.Moment;
    placeofBirthId: string;
    nationalityId: string;
    residencyNo: string | undefined;
    residencyExpireDate: moment.Moment;
    passportNo: string | undefined;
    passportExpireDate: moment.Moment;
    firstContactNumber: string | undefined;
    secondContactNumber: string | undefined;
    email: string | undefined;
    note: string | undefined;
    gender: number;
    order: number;
    marrigeDate: moment.Moment;
    isDivorced: boolean;
    divorceDate: moment.Moment | undefined;
    isDead: boolean;
    deathDate: moment.Moment | undefined;
    hasJob: boolean;
    jobTitle: string | undefined;
    companyName: string | undefined;
    workAddress: string | undefined;
    workPhone: string | undefined;
    workEmail: string | undefined;
}

export class UpdateTemporaryWorkshopDto implements IUpdateTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;

    constructor(data?: IUpdateTemporaryWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workshopId = _data["workshopId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.tempWorkshopId = _data["tempWorkshopId"];
        }
    }

    static fromJS(data: any): UpdateTemporaryWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemporaryWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workshopId"] = this.workshopId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["tempWorkshopId"] = this.tempWorkshopId;
        return data;
    }

    clone(): UpdateTemporaryWorkshopDto {
        const json = this.toJSON();
        let result = new UpdateTemporaryWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTemporaryWorkshopDto {
    id: string;
    workshopId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    tempWorkshopId: string;
}

export class UpdateTrainingDto implements IUpdateTrainingDto {
    id: string;

    constructor(data?: IUpdateTrainingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTrainingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateTrainingDto {
        const json = this.toJSON();
        let result = new UpdateTrainingDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTrainingDto {
    id: string;
}

export class UpdateTransferDto implements IUpdateTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationPositionId: string;
    startingDate: moment.Moment;
    description: string | undefined;

    constructor(data?: IUpdateTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.destinationJobTitleId = _data["destinationJobTitleId"];
            this.destinationPositionId = _data["destinationPositionId"];
            this.startingDate = _data["startingDate"] ? moment(_data["startingDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["destinationJobTitleId"] = this.destinationJobTitleId;
        data["destinationPositionId"] = this.destinationPositionId;
        data["startingDate"] = this.startingDate ? this.startingDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }

    clone(): UpdateTransferDto {
        const json = this.toJSON();
        let result = new UpdateTransferDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTransferDto {
    id: string;
    destinationJobTitleId: string;
    destinationPositionId: string;
    startingDate: moment.Moment;
    description: string | undefined;
}

export class UpdateTravelMissionDto implements IUpdateTravelMissionDto {
    id: string;
    employeeId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;

    constructor(data?: IUpdateTravelMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.employeeId = _data["employeeId"];
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.isTransferd = _data["isTransferd"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateTravelMissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTravelMissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["employeeId"] = this.employeeId;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["isTransferd"] = this.isTransferd;
        data["status"] = this.status;
        return data;
    }

    clone(): UpdateTravelMissionDto {
        const json = this.toJSON();
        let result = new UpdateTravelMissionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateTravelMissionDto {
    id: string;
    employeeId: string;
    fromDate: moment.Moment;
    toDate: moment.Moment;
    notes: string | undefined;
    isTransferd: boolean;
    status: Status;
}

export class UpdateWorkflowDto implements IUpdateWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    firstUserId: number;
    currentUserId: number;
    targetUserId: number;

    constructor(data?: IUpdateWorkflowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.creatorId = _data["creatorId"];
            this.firstUserId = _data["firstUserId"];
            this.currentUserId = _data["currentUserId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): UpdateWorkflowDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkflowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["description"] = this.description;
        data["status"] = this.status;
        data["type"] = this.type;
        data["creatorId"] = this.creatorId;
        data["firstUserId"] = this.firstUserId;
        data["currentUserId"] = this.currentUserId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }

    clone(): UpdateWorkflowDto {
        const json = this.toJSON();
        let result = new UpdateWorkflowDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkflowDto {
    id: string;
    date: string | undefined;
    description: string | undefined;
    status: number;
    type: number;
    creatorId: number;
    firstUserId: number;
    currentUserId: number;
    targetUserId: number;
}

export class UpdateWorkflowSettingDto implements IUpdateWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;

    constructor(data?: IUpdateWorkflowSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.steps = _data["steps"];
        }
    }

    static fromJS(data: any): UpdateWorkflowSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkflowSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["steps"] = this.steps;
        return data;
    }

    clone(): UpdateWorkflowSettingDto {
        const json = this.toJSON();
        let result = new UpdateWorkflowSettingDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkflowSettingDto {
    id: string;
    title: string | undefined;
    steps: number;
}

export class UpdateWorkshopDto implements IUpdateWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;

    constructor(data?: IUpdateWorkshopDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.attendanceFormId = _data["attendanceFormId"];
        }
    }

    static fromJS(data: any): UpdateWorkshopDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkshopDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["attendanceFormId"] = this.attendanceFormId;
        return data;
    }

    clone(): UpdateWorkshopDto {
        const json = this.toJSON();
        let result = new UpdateWorkshopDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateWorkshopDto {
    id: string;
    name: string | undefined;
    attendanceFormId: string;
}

export class User implements IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    readonly fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? moment(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
}

export class UserClaim implements IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDto implements IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? moment(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
}

export class WorkflowSetting implements IWorkflowSetting {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    steps: number;

    constructor(data?: IWorkflowSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.steps = _data["steps"];
        }
    }

    static fromJS(data: any): WorkflowSetting {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["steps"] = this.steps;
        return data;
    }

    clone(): WorkflowSetting {
        const json = this.toJSON();
        let result = new WorkflowSetting();
        result.init(json);
        return result;
    }
}

export interface IWorkflowSetting {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    title: string | undefined;
    steps: number;
}

export class Workshop implements IWorkshop {
    id: string;
    readonly domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    attendanceFormId: string;
    attendanceForm: AttendanceForm;
    normalShifts: NormalShift[] | undefined;

    constructor(data?: IWorkshop) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                (<any>this).domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    (<any>this).domainEvents.push(IEventData.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? moment(_data["deletionTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.attendanceFormId = _data["attendanceFormId"];
            this.attendanceForm = _data["attendanceForm"] ? AttendanceForm.fromJS(_data["attendanceForm"]) : <any>undefined;
            if (Array.isArray(_data["normalShifts"])) {
                this.normalShifts = [] as any;
                for (let item of _data["normalShifts"])
                    this.normalShifts.push(NormalShift.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Workshop {
        data = typeof data === 'object' ? data : {};
        let result = new Workshop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["attendanceFormId"] = this.attendanceFormId;
        data["attendanceForm"] = this.attendanceForm ? this.attendanceForm.toJSON() : <any>undefined;
        if (Array.isArray(this.normalShifts)) {
            data["normalShifts"] = [];
            for (let item of this.normalShifts)
                data["normalShifts"].push(item.toJSON());
        }
        return data;
    }

    clone(): Workshop {
        const json = this.toJSON();
        let result = new Workshop();
        result.init(json);
        return result;
    }
}

export interface IWorkshop {
    id: string;
    domainEvents: IEventData[] | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    name: string | undefined;
    attendanceFormId: string;
    attendanceForm: AttendanceForm;
    normalShifts: NormalShift[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}